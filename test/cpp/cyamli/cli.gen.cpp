// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <algorithm>
#include <cctype>
#include <string>
#include <tuple>
#include <cstdint>
#include <stdexcept>

namespace cyamli {

namespace {

// Helper functions
std::string to_lower(std::string const &s) {
    std::string r = s;
    std::transform(r.begin(), r.end(), r.begin(), [](char const c){ return std::tolower(c); });
    return r;
}

std::string join(std::vector<std::string> const &v, std::string const &sep) {
    std::string result;
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            result += sep;
        }
        result +=  v[i];
    }
    return result;
}

template <typename T, typename ...Args>
T parseValue(Args const &...strValue);

template <>
bool parseValue<bool>(std::string const &strValue) {
    auto lower = to_lower(strValue);
    if (lower == "true" || lower == "1" || lower == "t") {
        return true;
    }
    if (lower == "false" || lower == "0" || lower == "f") {
        return false;
    }
    throw std::runtime_error("fail to parse empty value as bool");
}

template <>
std::int64_t parseValue<std::int64_t>(std::string const &strValue) {
    return static_cast<std::int64_t>(std::stoll(strValue));
}

template <>
std::string parseValue<std::string>(std::string const &strValue) {
    return strValue;
}

template <>
std::vector<bool> parseValue<std::vector<bool>>(std::vector<std::string> const &strValue) {
    std::vector<bool> result;
    for (const auto& val : strValue) {
        result.push_back(parseValue<bool>(val));
    }
    return result;
}

template <>
std::vector<std::int64_t> parseValue<std::vector<std::int64_t>>(std::vector<std::string> const &strValue) {
    std::vector<std::int64_t> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::int64_t>(val));
    }
    return result;
}

template <>
std::vector<std::string> parseValue<std::vector<std::string>>(std::vector<std::string> const &strValue) {
    std::vector<std::string> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::string>(val));
    }
    return result;
}

} // namespace

std::tuple<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>>
resolveArgs(std::vector<std::string> const &args) {
    if (args.empty()) {
        throw std::runtime_error("command line arguments are too few");
    }
    std::vector<std::string> subcommandSet = {
        "","generate","generate dart3","generate docs","generate golang","generate kotlin","generate python3","generate typescript","version",
    };
    std::vector<std::string> subcommandPath, options, arguments;
    for (size_t i = 1; i < args.size(); ++i) {
        if (args[i] == "--") {
            break;
        }
        std::string pathLiteral = join(subcommandPath, " ");
        if (!pathLiteral.empty()) pathLiteral += " ";
        pathLiteral += args[i];
        if (std::find(subcommandSet.begin(), subcommandSet.end(), pathLiteral) == subcommandSet.end()){
            break;
        }
        subcommandPath.emplace_back(args[i]);
    }
    auto restArgs = std::vector<std::string>(args.begin() + 1 + subcommandPath.size(), args.end());
    for (size_t idx = 0; idx < restArgs.size(); ++idx) {
        auto const &arg = restArgs[idx];
        if (arg == "--") {
            arguments.insert(arguments.end(), restArgs.begin() + idx + 1, restArgs.end());
            break;
        }
        if (arg.size() > 0 && arg[0] == '-') {
            options.emplace_back(arg);
        } else {
            arguments.emplace_back(arg);
        }
    }
    return std::make_tuple(subcommandPath, options, arguments);
};
void Run(CLIHandler& handler, int argc, const char *argv[]) {
    std::vector<std::string> args;
    for (int i = 0; i < argc; ++i) {
        args.emplace_back(argv[i]);
    }
    auto tup = resolveArgs(args);
    auto const &subcommandPath = std::get<0>(tup);
    auto const &options = std::get<1>(tup);
    auto const &arguments = std::get<2>(tup);
    std::string subcommandKey = join(subcommandPath, " ");
    // Dispatch
    
    if (subcommandKey == "") {
        Input input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run(input);
        return;
    }
    
    if (subcommandKey == "generate") {
        Input_Generate input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Generate(input);
        return;
    }
    
    if (subcommandKey == "generate dart3") {
        Input_GenerateDart3 input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GenerateDart3(input);
        return;
    }
    
    if (subcommandKey == "generate docs") {
        Input_GenerateDocs input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GenerateDocs(input);
        return;
    }
    
    if (subcommandKey == "generate golang") {
        Input_GenerateGolang input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GenerateGolang(input);
        return;
    }
    
    if (subcommandKey == "generate kotlin") {
        Input_GenerateKotlin input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GenerateKotlin(input);
        return;
    }
    
    if (subcommandKey == "generate python3") {
        Input_GeneratePython3 input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GeneratePython3(input);
        return;
    }
    
    if (subcommandKey == "generate typescript") {
        Input_GenerateTypescript input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_GenerateTypescript(input);
        return;
    }
    
    if (subcommandKey == "version") {
        Input_Version input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Version(input);
        return;
    }
    
}


void Input::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_Generate::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GenerateDart3::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GenerateDocs::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Format = "text";
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-format" || optName == "-f") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Format = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GenerateGolang::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_Package = "main";
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-package") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Package = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GenerateKotlin::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_Package = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-package") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Package = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GeneratePython3::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_GenerateTypescript::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    this->Opt_OutPath = std::string("");
    this->Opt_SchemaPath = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-out-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_OutPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-schema-path") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_SchemaPath = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_Version::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Help = false;
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-help" || optName == "-h") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_Help = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}

std::string GetVersion() {
    return "2.0.0-alpha.1";
}
std::string GetProgram() {
    return "cyamli";
}
std::string GetDoc(std::vector<std::string> const &subcommands) {
    std::string key = join(subcommands, " ");
    
    if (key == "") return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";
    
    if (key == "generate") return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";
    
    if (key == "generate dart3") return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "generate docs") return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>(default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "generate golang") return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>(default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "generate kotlin") return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>(default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "generate python3") return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "generate typescript") return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
    
    if (key == "version") return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n\n";
    
    throw std::runtime_error("invalid subcommands: " + key);
}

} // namespace
