// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <cstdint>
#include <stdexcept>

template <typename T>
std::ostream& operator<<(std::ostream& os, std::vector<T> const &v) {
    os << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            os << ", ";
        }
        os << v[i];
    }
    return os << "]";
}

#define TEST_ASSERT_EQUAL(name, got, want) \
     if ((got) != (want)) { \
        std::cout << "[FAIL] " << (std::string(__func__) + " at " + std::string(__FILE__) + ":" + std::to_string(__LINE__)) << ": " << (name) << std::endl; \
        std::cout << "Want = " << (want) << std::endl; \
        std::cout << "Got  = " << (got) << std::endl; \
        std::exit(1); \
    }

namespace cyamli {

struct CLIHandlerMock : public CLIHandler {
    void* gotInput = nullptr;
    
    void Run(const Input& input) override {
        gotInput = (void *)new Input(input);
    }
    
    void Run_Generate(const Input_Generate& input) override {
        gotInput = (void *)new Input_Generate(input);
    }
    
    void Run_GenerateDart3(const Input_GenerateDart3& input) override {
        gotInput = (void *)new Input_GenerateDart3(input);
    }
    
    void Run_GenerateDocs(const Input_GenerateDocs& input) override {
        gotInput = (void *)new Input_GenerateDocs(input);
    }
    
    void Run_GenerateGolang(const Input_GenerateGolang& input) override {
        gotInput = (void *)new Input_GenerateGolang(input);
    }
    
    void Run_GenerateKotlin(const Input_GenerateKotlin& input) override {
        gotInput = (void *)new Input_GenerateKotlin(input);
    }
    
    void Run_GeneratePython3(const Input_GeneratePython3& input) override {
        gotInput = (void *)new Input_GeneratePython3(input);
    }
    
    void Run_GenerateTypescript(const Input_GenerateTypescript& input) override {
        gotInput = (void *)new Input_GenerateTypescript(input);
    }
    
    void Run_Version(const Input_Version& input) override {
        gotInput = (void *)new Input_Version(input);
    }
    
};


void test_Run() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "-help=0","--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "-h=0","--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "-help=0","--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "-help=0","--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "-help=0","--",},
            []{
                Input v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        
    }
    std::cout << "[PASS] Run" << std::endl;
}

void test_Run_Generate() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Generate wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "-h=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_Generate v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Generate *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_Generate" << std::endl;
}

void test_Run_GenerateDart3() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GenerateDart3 wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "dart3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "dart3", "--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "dart3", "-h=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "dart3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "dart3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "dart3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDart3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GenerateDart3 *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GenerateDart3" << std::endl;
}

void test_Run_GenerateDocs() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GenerateDocs wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "docs", "-format=0","-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "0";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "docs", "--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "text";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "docs", "-f=0","-h=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "0";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "docs", "-format=0","-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "0";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "docs", "-format=0","-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "0";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "docs", "-format=0","-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateDocs v;
                
                v.Opt_Format = "0";
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GenerateDocs *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -format", want.Opt_Format, got->Opt_Format);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GenerateDocs" << std::endl;
}

void test_Run_GenerateGolang() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GenerateGolang wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "golang", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "golang", "--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_Package = "main";
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "golang", "-h=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "golang", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "golang", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "golang", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateGolang v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GenerateGolang *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -package", want.Opt_Package, got->Opt_Package);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GenerateGolang" << std::endl;
}

void test_Run_GenerateKotlin() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GenerateKotlin wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "kotlin", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "kotlin", "--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_Package = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "kotlin", "-h=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "kotlin", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "kotlin", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "kotlin", "-help=0","-out-path=0","-package=0","-schema-path=0","--",},
            []{
                Input_GenerateKotlin v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_Package = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GenerateKotlin *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -package", want.Opt_Package, got->Opt_Package);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GenerateKotlin" << std::endl;
}

void test_Run_GeneratePython3() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GeneratePython3 wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "python3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "python3", "--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "python3", "-h=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "python3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "python3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "python3", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GeneratePython3 v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GeneratePython3 *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GeneratePython3" << std::endl;
}

void test_Run_GenerateTypescript() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_GenerateTypescript wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "generate", "typescript", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "generate", "typescript", "--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = std::string("");
                
                v.Opt_SchemaPath = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "generate", "typescript", "-h=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "generate", "typescript", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "generate", "typescript", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "generate", "typescript", "-help=0","-out-path=0","-schema-path=0","--",},
            []{
                Input_GenerateTypescript v;
                
                v.Opt_Help = false;
                
                v.Opt_OutPath = "0";
                
                v.Opt_SchemaPath = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_GenerateTypescript *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -out-path", want.Opt_OutPath, got->Opt_OutPath);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -schema-path", want.Opt_SchemaPath, got->Opt_SchemaPath);
        
        
    }
    std::cout << "[PASS] Run_GenerateTypescript" << std::endl;
}

void test_Run_Version() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Version wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "version", "-help=0","--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "version", "--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "version", "-h=0","--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "version", "-help=0","--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "version", "-help=0","--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "version", "-help=0","--",},
            []{
                Input_Version v;
                
                v.Opt_Help = false;
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Version *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -help", want.Opt_Help, got->Opt_Help);
        
        
    }
    std::cout << "[PASS] Run_Version" << std::endl;
}


} // namespace cyamli

int main() {
    
    
    cyamli::test_Run();
    
    cyamli::test_Run_Generate();
    
    cyamli::test_Run_GenerateDart3();
    
    cyamli::test_Run_GenerateDocs();
    
    cyamli::test_Run_GenerateGolang();
    
    cyamli::test_Run_GenerateKotlin();
    
    cyamli::test_Run_GeneratePython3();
    
    cyamli::test_Run_GenerateTypescript();
    
    cyamli::test_Run_Version();
    
    std::cout << "All tests passed." << std::endl;
    return 0;
}

