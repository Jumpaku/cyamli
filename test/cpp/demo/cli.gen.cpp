// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <algorithm>
#include <cctype>
#include <string>
#include <tuple>
#include <cstdint>
#include <stdexcept>

namespace demo {

namespace {

// Helper functions
std::string to_lower(std::string const &s) {
    std::string r = s;
    std::transform(r.begin(), r.end(), r.begin(), [](char const c){ return std::tolower(c); });
    return r;
}

std::string join(std::vector<std::string> const &v, std::string const &sep) {
    std::string result;
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            result += sep;
        }
        result +=  v[i];
    }
    return result;
}

template <typename T, typename ...Args>
T parseValue(Args const &...strValue);

template <>
bool parseValue<bool>(std::string const &strValue) {
    auto lower = to_lower(strValue);
    if (lower == "true" || lower == "1" || lower == "t") {
        return true;
    }
    if (lower == "false" || lower == "0" || lower == "f") {
        return false;
    }
    throw std::runtime_error("fail to parse empty value as bool");
}

template <>
std::int64_t parseValue<std::int64_t>(std::string const &strValue) {
    return static_cast<std::int64_t>(std::stoll(strValue));
}

template <>
std::string parseValue<std::string>(std::string const &strValue) {
    return strValue;
}

template <>
std::vector<bool> parseValue<std::vector<bool>>(std::vector<std::string> const &strValue) {
    std::vector<bool> result;
    for (const auto& val : strValue) {
        result.push_back(parseValue<bool>(val));
    }
    return result;
}

template <>
std::vector<std::int64_t> parseValue<std::vector<std::int64_t>>(std::vector<std::string> const &strValue) {
    std::vector<std::int64_t> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::int64_t>(val));
    }
    return result;
}

template <>
std::vector<std::string> parseValue<std::vector<std::string>>(std::vector<std::string> const &strValue) {
    std::vector<std::string> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::string>(val));
    }
    return result;
}

} // namespace

std::tuple<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>>
resolveArgs(std::vector<std::string> const &args) {
    if (args.empty()) {
        throw std::runtime_error("command line arguments are too few");
    }
    std::vector<std::string> subcommandSet = {
        "","data","schema","tables",
    };
    std::vector<std::string> subcommandPath, options, arguments;
    for (size_t i = 1; i < args.size(); ++i) {
        if (args[i] == "--") {
            break;
        }
        std::string pathLiteral = join(subcommandPath, " ");
        if (!pathLiteral.empty()) pathLiteral += " ";
        pathLiteral += args[i];
        if (std::find(subcommandSet.begin(), subcommandSet.end(), pathLiteral) == subcommandSet.end()){
            break;
        }
        subcommandPath.emplace_back(args[i]);
    }
    auto restArgs = std::vector<std::string>(args.begin() + 1 + subcommandPath.size(), args.end());
    for (size_t idx = 0; idx < restArgs.size(); ++idx) {
        auto const &arg = restArgs[idx];
        if (arg == "--") {
            arguments.insert(arguments.end(), restArgs.begin() + idx + 1, restArgs.end());
            break;
        }
        if (arg.size() > 0 && arg[0] == '-') {
            options.emplace_back(arg);
        } else {
            arguments.emplace_back(arg);
        }
    }
    return std::make_tuple(subcommandPath, options, arguments);
};
void Run(CLIHandler& handler, int argc, const char *argv[]) {
    std::vector<std::string> args;
    for (int i = 0; i < argc; ++i) {
        args.emplace_back(argv[i]);
    }
    auto tup = resolveArgs(args);
    auto const &subcommandPath = std::get<0>(tup);
    auto const &options = std::get<1>(tup);
    auto const &arguments = std::get<2>(tup);
    std::string subcommandKey = join(subcommandPath, " ");
    // Dispatch
    
    if (subcommandKey == "") {
        Input input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run(input);
        return;
    }
    
    if (subcommandKey == "data") {
        Input_Data input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Data(input);
        return;
    }
    
    if (subcommandKey == "schema") {
        Input_Schema input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Schema(input);
        return;
    }
    
    if (subcommandKey == "tables") {
        Input_Tables input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Tables(input);
        return;
    }
    
}


void Input::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Config = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-config") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Config = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_Data::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Config = std::string("");
    this->Opt_Where = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-config") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Config = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-where") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Where = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 1;
    if (this->Arguments.size() <= 0) {
        this->ErrorMessage = "too few arguments: required " + std::to_string(expectedArgs) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->Arg_Table = parseValue<std::string>(this->Arguments[0]);
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + this->Arguments[0] + "': " + e.what();
        return;
    }
    
}


void Input_Schema::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Config = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-config") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Config = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 1;
    if (this->Arguments.size() <= 0) {
        this->ErrorMessage = "too few arguments: required " + std::to_string(expectedArgs) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->Arg_Table = parseValue<std::string>(this->Arguments[0]);
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + this->Arguments[0] + "': " + e.what();
        return;
    }
    
}


void Input_Tables::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_Config = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-config") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Config = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}

std::string GetVersion() {
    return "";
}
std::string GetProgram() {
    return "demo";
}
std::string GetDoc(std::vector<std::string> const &subcommands) {
    std::string key = join(subcommands, " ");
    
    if (key == "") return "demo \n\n    Syntax:\n        $ demo  [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Subcommands:\n        data:\n            dump data from the specified table from the database.\n\n        schema:\n            fetch schema of the specified table from the database.\n\n        tables:\n            list tables from the database.\n\n\n";
    
    if (key == "data") return "demo data\n\n    Description:\n        dump data from the specified table from the database.\n\n    Syntax:\n        $ demo data [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n        -where=<string>  (default=\"\"):\n            filter data by the condition.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
    
    if (key == "schema") return "demo schema\n\n    Description:\n        fetch schema of the specified table from the database.\n\n    Syntax:\n        $ demo schema [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
    
    if (key == "tables") return "demo tables\n\n    Description:\n        list tables from the database.\n\n    Syntax:\n        $ demo tables [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n\n";
    
    throw std::runtime_error("invalid subcommands: " + key);
}

} // namespace
