// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <cstdint>
#include <stdexcept>

template <typename T>
std::ostream& operator<<(std::ostream& os, std::vector<T> const &v) {
    os << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            os << ", ";
        }
        os << v[i];
    }
    return os << "]";
}

#define TEST_ASSERT_EQUAL(name, got, want) \
     if ((got) != (want)) { \
        std::cout << "[FAIL] " << (std::string(__func__) + " at " + std::string(__FILE__) + ":" + std::to_string(__LINE__)) << ": " << (name) << std::endl; \
        std::cout << "Want = " << (want) << std::endl; \
        std::cout << "Got  = " << (got) << std::endl; \
        std::exit(1); \
    }

namespace demo {

struct CLIHandlerMock : public CLIHandler {
    void* gotInput = nullptr;
    
    void Run(const Input& input) override {
        gotInput = (void *)new Input(input);
    }
    
    void Run_Data(const Input_Data& input) override {
        gotInput = (void *)new Input_Data(input);
    }
    
    void Run_Schema(const Input_Schema& input) override {
        gotInput = (void *)new Input_Schema(input);
    }
    
    void Run_Tables(const Input_Tables& input) override {
        gotInput = (void *)new Input_Tables(input);
    }
    
};


void test_Run() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "-config=0","--",},
            []{
                Input v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "--",},
            []{
                Input v;
                
                v.Opt_Config = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "-config=0","--",},
            []{
                Input v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "-config=0","--",},
            []{
                Input v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "-config=0","--",},
            []{
                Input v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "-config=0","--",},
            []{
                Input v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -config", want.Opt_Config, got->Opt_Config);
        
        
    }
    std::cout << "[PASS] Run" << std::endl;
}

void test_Run_Data() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Data wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "data", "-config=0","-where=0","--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = "0";
                
                v.Opt_Where = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "data", "--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = std::string("");
                
                v.Opt_Where = std::string("");
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "data", "-config=0","-where=0","--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = "0";
                
                v.Opt_Where = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "data", "-config=0","-where=0","--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = "0";
                
                v.Opt_Where = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "data", "-config=0","-where=0","--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = "0";
                
                v.Opt_Where = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "data", "-config=0","-where=0","--","0",},
            []{
                Input_Data v;
                
                v.Opt_Config = "0";
                
                v.Opt_Where = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Data *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -config", want.Opt_Config, got->Opt_Config);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -where", want.Opt_Where, got->Opt_Where);
        
        
        TEST_ASSERT_EQUAL(tc.name + ": argument: table", want.Arg_Table, got->Arg_Table);
        
    }
    std::cout << "[PASS] Run_Data" << std::endl;
}

void test_Run_Schema() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Schema wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "schema", "-config=0","--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "schema", "--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = std::string("");
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "schema", "-config=0","--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "schema", "-config=0","--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "schema", "-config=0","--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "schema", "-config=0","--","0",},
            []{
                Input_Schema v;
                
                v.Opt_Config = "0";
                
                
                v.Arg_Table = "0";
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Schema *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -config", want.Opt_Config, got->Opt_Config);
        
        
        TEST_ASSERT_EQUAL(tc.name + ": argument: table", want.Arg_Table, got->Arg_Table);
        
    }
    std::cout << "[PASS] Run_Schema" << std::endl;
}

void test_Run_Tables() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Tables wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "tables", "-config=0","--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "tables", "--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "tables", "-config=0","--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "tables", "-config=0","--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "tables", "-config=0","--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "tables", "-config=0","--",},
            []{
                Input_Tables v;
                
                v.Opt_Config = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Tables *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -config", want.Opt_Config, got->Opt_Config);
        
        
    }
    std::cout << "[PASS] Run_Tables" << std::endl;
}


} // namespace demo

int main() {
    
    
    demo::test_Run();
    
    demo::test_Run_Data();
    
    demo::test_Run_Schema();
    
    demo::test_Run_Tables();
    
    std::cout << "All tests passed." << std::endl;
    return 0;
}

