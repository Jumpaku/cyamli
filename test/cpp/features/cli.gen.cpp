// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <algorithm>
#include <cctype>
#include <string>
#include <tuple>
#include <cstdint>
#include <stdexcept>

namespace features {

namespace {

// Helper functions
std::string to_lower(std::string const &s) {
    std::string r = s;
    std::transform(r.begin(), r.end(), r.begin(), [](char const c){ return std::tolower(c); });
    return r;
}

std::string join(std::vector<std::string> const &v, std::string const &sep) {
    std::string result;
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            result += sep;
        }
        result +=  v[i];
    }
    return result;
}

template <typename T, typename ...Args>
T parseValue(Args const &...strValue);

template <>
bool parseValue<bool>(std::string const &strValue) {
    auto lower = to_lower(strValue);
    if (lower == "true" || lower == "1" || lower == "t") {
        return true;
    }
    if (lower == "false" || lower == "0" || lower == "f") {
        return false;
    }
    throw std::runtime_error("fail to parse empty value as bool");
}

template <>
std::int64_t parseValue<std::int64_t>(std::string const &strValue) {
    return static_cast<std::int64_t>(std::stoll(strValue));
}

template <>
std::string parseValue<std::string>(std::string const &strValue) {
    return strValue;
}

template <>
std::vector<bool> parseValue<std::vector<bool>>(std::vector<std::string> const &strValue) {
    std::vector<bool> result;
    for (const auto& val : strValue) {
        result.push_back(parseValue<bool>(val));
    }
    return result;
}

template <>
std::vector<std::int64_t> parseValue<std::vector<std::int64_t>>(std::vector<std::string> const &strValue) {
    std::vector<std::int64_t> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::int64_t>(val));
    }
    return result;
}

template <>
std::vector<std::string> parseValue<std::vector<std::string>>(std::vector<std::string> const &strValue) {
    std::vector<std::string> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::string>(val));
    }
    return result;
}

} // namespace

std::tuple<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>>
resolveArgs(std::vector<std::string> const &args) {
    if (args.empty()) {
        throw std::runtime_error("command line arguments are too few");
    }
    std::vector<std::string> subcommandSet = {
        "","sub1","sub1 sub2","sub1 sub2 sub3",
    };
    std::vector<std::string> subcommandPath, options, arguments;
    for (size_t i = 1; i < args.size(); ++i) {
        if (args[i] == "--") {
            break;
        }
        std::string pathLiteral = join(subcommandPath, " ");
        if (!pathLiteral.empty()) pathLiteral += " ";
        pathLiteral += args[i];
        if (std::find(subcommandSet.begin(), subcommandSet.end(), pathLiteral) == subcommandSet.end()){
            break;
        }
        subcommandPath.emplace_back(args[i]);
    }
    auto restArgs = std::vector<std::string>(args.begin() + 1 + subcommandPath.size(), args.end());
    for (size_t idx = 0; idx < restArgs.size(); ++idx) {
        auto const &arg = restArgs[idx];
        if (arg == "--") {
            arguments.insert(arguments.end(), restArgs.begin() + idx + 1, restArgs.end());
            break;
        }
        if (arg.size() > 0 && arg[0] == '-') {
            options.emplace_back(arg);
        } else {
            arguments.emplace_back(arg);
        }
    }
    return std::make_tuple(subcommandPath, options, arguments);
};
void Run(CLIHandler& handler, int argc, const char *argv[]) {
    std::vector<std::string> args;
    for (int i = 0; i < argc; ++i) {
        args.emplace_back(argv[i]);
    }
    auto tup = resolveArgs(args);
    auto const &subcommandPath = std::get<0>(tup);
    auto const &options = std::get<1>(tup);
    auto const &arguments = std::get<2>(tup);
    std::string subcommandKey = join(subcommandPath, " ");
    // Dispatch
    
    if (subcommandKey == "") {
        Input input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run(input);
        return;
    }
    
    if (subcommandKey == "sub1") {
        Input_Sub1 input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Sub1(input);
        return;
    }
    
    if (subcommandKey == "sub1 sub2") {
        Input_Sub1Sub2 input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Sub1Sub2(input);
        return;
    }
    
    if (subcommandKey == "sub1 sub2 sub3") {
        Input_Sub1Sub2Sub3 input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.Run_Sub1Sub2Sub3(input);
        return;
    }
    
}


void Input::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_NegationOption = false;
    this->Opt_Option = 123;
    this->Opt_PropagationOption = std::string("");
    this->Opt_RepeatableOption = std::vector<std::int64_t>{};
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-negation-option") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_NegationOption = parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        else if (optName == "-no-negation-option") {
            if (!cut) {
                lit = "true";
            }
            try {
				this->Opt_NegationOption = !parseValue<bool>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-option" || optName == "-o") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_Option = parseValue<std::int64_t>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-propagation-option") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_PropagationOption = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else if (optName == "-repeatable-option" || optName == "-r") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				auto v = parseValue<std::vector<std::int64_t>>(std::vector<std::string>{lit});
				this->Opt_RepeatableOption.insert(this->Opt_RepeatableOption.end(), v.begin(), v.end());
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 3;
    if (this->Arguments.size() <= 0) {
        this->ErrorMessage = "too few arguments: required " + std::to_string(expectedArgs) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->Arg_FirstArg = parseValue<bool>(this->Arguments[0]);
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + this->Arguments[0] + "': " + e.what();
        return;
    }
    
    if (this->Arguments.size() <= 1) {
        this->ErrorMessage = "too few arguments: required " + std::to_string(expectedArgs) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->Arg_SecondArg = parseValue<std::int64_t>(this->Arguments[1]);
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + this->Arguments[1] + "': " + e.what();
        return;
    }
    
    if (this->Arguments.size() < 2) {
        this->ErrorMessage = "too few arguments: required at least " + std::to_string(expectedArgs-1) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->Arg_ThirdArg = parseValue<std::vector<std::string>>(std::vector<std::string>(this->Arguments.begin() + 2, this->Arguments.end()));
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + join(std::vector<std::string>(this->Arguments.begin() + 2, this->Arguments.end()), ", ") + "': " + e.what();
        return;
    }
    
}


void Input_Sub1::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_PropagationOption = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-propagation-option") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_PropagationOption = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_Sub1Sub2::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_PropagationOption = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-propagation-option") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_PropagationOption = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}


void Input_Sub1Sub2Sub3::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    this->Opt_PropagationOption = std::string("");
    
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        else if (optName == "-propagation-option") {
            if (!cut) {
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
            }
            try {
				this->Opt_PropagationOption = parseValue<std::string>(lit);
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        
        
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = 0;
}

std::string GetVersion() {
    return "1.2.3";
}
std::string GetProgram() {
    return "features";
}
std::string GetDoc(std::vector<std::string> const &subcommands) {
    std::string key = join(subcommands, " ");
    
    if (key == "") return "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        $ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>](default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>(default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<integer> ... , -r=<integer> ... :\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n";
    
    if (key == "sub1") return "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        $ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n";
    
    if (key == "sub1 sub2") return "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n";
    
    if (key == "sub1 sub2 sub3") return "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n\n";
    
    throw std::runtime_error("invalid subcommands: " + key);
}

} // namespace
