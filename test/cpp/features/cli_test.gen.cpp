// Code generated by cyamli, DO NOT EDIT.
#include "cli.gen.h"
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <cstdint>
#include <stdexcept>

template <typename T>
std::ostream& operator<<(std::ostream& os, std::vector<T> const &v) {
    os << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            os << ", ";
        }
        os << v[i];
    }
    return os << "]";
}

#define TEST_ASSERT_EQUAL(name, got, want) \
     if ((got) != (want)) { \
        std::cout << "[FAIL] " << (std::string(__func__) + " at " + std::string(__FILE__) + ":" + std::to_string(__LINE__)) << ": " << (name) << std::endl; \
        std::cout << "Want = " << (want) << std::endl; \
        std::cout << "Got  = " << (got) << std::endl; \
        std::exit(1); \
    }

namespace features {

struct CLIHandlerMock : public CLIHandler {
    void* gotInput = nullptr;
    
    void Run(const Input& input) override {
        gotInput = (void *)new Input(input);
    }
    
    void Run_Sub1(const Input_Sub1& input) override {
        gotInput = (void *)new Input_Sub1(input);
    }
    
    void Run_Sub1Sub2(const Input_Sub1Sub2& input) override {
        gotInput = (void *)new Input_Sub1Sub2(input);
    }
    
    void Run_Sub1Sub2Sub3(const Input_Sub1Sub2Sub3& input) override {
        gotInput = (void *)new Input_Sub1Sub2Sub3(input);
    }
    
};


void test_Run() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "-negation-option=0","-option=0","-propagation-option=0","-repeatable-option=0","--","0","0","0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 0;
                
                v.Opt_PropagationOption = "0";
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{0};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{"0"};
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "--","0","0","0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 123;
                
                v.Opt_PropagationOption = std::string("");
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{"0"};
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "-negation-option=0","-o=0","-propagation-option=0","-r=0","--","0","0","0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 0;
                
                v.Opt_PropagationOption = "0";
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{0};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{"0"};
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "-no-negation-option=1","-option=0","-propagation-option=0","-repeatable-option=0","--","0","0","0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 0;
                
                v.Opt_PropagationOption = "0";
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{0};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{"0"};
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "-no-negation-option=1","-option=0","-propagation-option=0","-repeatable-option=0","--","0","0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 0;
                
                v.Opt_PropagationOption = "0";
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{0};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{};
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "-no-negation-option=1","-option=0","-propagation-option=0","-repeatable-option=0","--","0","0","0", "0",},
            []{
                Input v;
                
                v.Opt_NegationOption = false;
                
                v.Opt_Option = 0;
                
                v.Opt_PropagationOption = "0";
                
                v.Opt_RepeatableOption = std::vector<std::int64_t>{0};
                
                
                v.Arg_FirstArg = false;
                
                v.Arg_SecondArg = 0;
                
                v.Arg_ThirdArg = std::vector<std::string>{"0", "0"};
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -negation-option", want.Opt_NegationOption, got->Opt_NegationOption);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -option", want.Opt_Option, got->Opt_Option);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -propagation-option", want.Opt_PropagationOption, got->Opt_PropagationOption);
        
        TEST_ASSERT_EQUAL(tc.name + ": option: -repeatable-option", want.Opt_RepeatableOption, got->Opt_RepeatableOption);
        
        
        TEST_ASSERT_EQUAL(tc.name + ": argument: first_arg", want.Arg_FirstArg, got->Arg_FirstArg);
        
        TEST_ASSERT_EQUAL(tc.name + ": argument: second_arg", want.Arg_SecondArg, got->Arg_SecondArg);
        
        TEST_ASSERT_EQUAL(tc.name + ": argument: third_arg", want.Arg_ThirdArg, got->Arg_ThirdArg);
        
    }
    std::cout << "[PASS] Run" << std::endl;
}

void test_Run_Sub1() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Sub1 wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "sub1", "-propagation-option=0","--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "sub1", "--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "sub1", "-propagation-option=0","--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "sub1", "-propagation-option=0","--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "sub1", "-propagation-option=0","--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "sub1", "-propagation-option=0","--",},
            []{
                Input_Sub1 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Sub1 *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -propagation-option", want.Opt_PropagationOption, got->Opt_PropagationOption);
        
        
    }
    std::cout << "[PASS] Run_Sub1" << std::endl;
}

void test_Run_Sub1Sub2() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Sub1Sub2 wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "sub1", "sub2", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "sub1", "sub2", "--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "sub1", "sub2", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "sub1", "sub2", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "sub1", "sub2", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "sub1", "sub2", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Sub1Sub2 *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -propagation-option", want.Opt_PropagationOption, got->Opt_PropagationOption);
        
        
    }
    std::cout << "[PASS] Run_Sub1Sub2" << std::endl;
}

void test_Run_Sub1Sub2Sub3() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        Input_Sub1Sub2Sub3 wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", "sub1", "sub2", "sub3", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", "sub1", "sub2", "sub3", "--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = std::string("");
                
                
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", "sub1", "sub2", "sub3", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", "sub1", "sub2", "sub3", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", "sub1", "sub2", "sub3", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", "sub1", "sub2", "sub3", "-propagation-option=0","--",},
            []{
                Input_Sub1Sub2Sub3 v;
                
                v.Opt_PropagationOption = "0";
                
                
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<Input_Sub1Sub2Sub3 *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        
        TEST_ASSERT_EQUAL(tc.name + ": option: -propagation-option", want.Opt_PropagationOption, got->Opt_PropagationOption);
        
        
    }
    std::cout << "[PASS] Run_Sub1Sub2Sub3" << std::endl;
}


} // namespace features

int main() {
    
    
    features::test_Run();
    
    features::test_Run_Sub1();
    
    features::test_Run_Sub1Sub2();
    
    features::test_Run_Sub1Sub2Sub3();
    
    std::cout << "All tests passed." << std::endl;
    return 0;
}

