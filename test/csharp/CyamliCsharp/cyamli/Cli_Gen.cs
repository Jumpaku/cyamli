// Code generated by cyamli, DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.Linq;

namespace cyamli {

public interface ICliHandler {
    void Run(Cli.Input input);
    void Run_Generate(Cli.Input_Generate input);
    void Run_GenerateDart3(Cli.Input_GenerateDart3 input);
    void Run_GenerateDocs(Cli.Input_GenerateDocs input);
    void Run_GenerateGolang(Cli.Input_GenerateGolang input);
    void Run_GenerateKotlin(Cli.Input_GenerateKotlin input);
    void Run_GeneratePython3(Cli.Input_GeneratePython3 input);
    void Run_GenerateTypescript(Cli.Input_GenerateTypescript input);
    void Run_Version(Cli.Input_Version input);
    
}

public static class Cli {
    public static void Run(ICliHandler handler, string[] args) {
        var (subcommandPath, options, arguments) = ResolveArgs(args);
        switch (string.Join(" ", subcommandPath)) {
            
            case "":
                {
                    var input = new Input();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run(input);
                }
                break;
            
            case "generate":
                {
                    var input = new Input_Generate();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Generate(input);
                }
                break;
            
            case "generate dart3":
                {
                    var input = new Input_GenerateDart3();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GenerateDart3(input);
                }
                break;
            
            case "generate docs":
                {
                    var input = new Input_GenerateDocs();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GenerateDocs(input);
                }
                break;
            
            case "generate golang":
                {
                    var input = new Input_GenerateGolang();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GenerateGolang(input);
                }
                break;
            
            case "generate kotlin":
                {
                    var input = new Input_GenerateKotlin();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GenerateKotlin(input);
                }
                break;
            
            case "generate python3":
                {
                    var input = new Input_GeneratePython3();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GeneratePython3(input);
                }
                break;
            
            case "generate typescript":
                {
                    var input = new Input_GenerateTypescript();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_GenerateTypescript(input);
                }
                break;
            
            case "version":
                {
                    var input = new Input_Version();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Version(input);
                }
                break;
            }
    }

    
    public class Input {
        public bool Opt_Help = false;
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_Generate {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GenerateDart3 {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GenerateDocs {
        public string Opt_Format = "text";
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-format":
                case "-f":
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Format = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GenerateGolang {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_Package = "main";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-package":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Package = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GenerateKotlin {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_Package = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-package":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Package = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GeneratePython3 {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_GenerateTypescript {
        public bool Opt_Help = false;
        public string Opt_OutPath = "";
        public string Opt_SchemaPath = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-out-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_OutPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-schema-path":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_SchemaPath = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_Version {
        public bool Opt_Help = false;
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-help":
                case "-h":
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_Help = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    

    private static (List<string> subcommandPath, List<string> options, List<string> arguments) ResolveArgs(string[] args) {
        if (args.Length == 0) throw new Exception("command line arguments are too few");
        var subcommandSet = new HashSet<string> {
            "","generate","generate dart3","generate docs","generate golang","generate kotlin","generate python3","generate typescript","version",
        };
        var subcommandPath = new List<string>();
        var options = new List<string>();
        var arguments = new List<string>();
        for (int i = 1; i < args.Length; i++) {
            if (args[i] == "--") break;
            var pathLiteral = string.Join(" ", subcommandPath.Concat(new[]{args[i]}));
            if (!subcommandSet.Contains(pathLiteral)) break;
            subcommandPath.Add(args[i]);
        }
        var restArgs = args.Skip(1 + subcommandPath.Count).ToArray();
        for (int idx = 0; idx < restArgs.Length; idx++) {
            var arg = restArgs[idx];
            if (arg == "--") {
                arguments.AddRange(restArgs.Skip(idx + 1));
                break;
            }
            if (arg.StartsWith("-")) options.Add(arg);
            else arguments.Add(arg);
        }
        return (subcommandPath, options, arguments);
    }

    private static object ParseValue(string typ, params string[] strValue) {
        switch (typ) {
            case "List<bool>":
                return strValue.Select(s => (bool)ParseValue("bool", s)).ToList();
            case "List<long>":
                return strValue.Select(s => (long)ParseValue("long", s)).ToList();
            case "List<string>":
                return strValue.Select(s => (string)ParseValue("string", s)).ToList();
            case "bool":
                switch (strValue[0].ToLower()) {
                    case "true": case "1": case "t": return true;
                    case "false": case "0": case "f": return false;
                    default: throw new Exception($"fail to parse {strValue[0]} as bool: unknown value");
                }
            case "long":
                return long.Parse(strValue[0]);
            case "string":
                return strValue[0];
        }
        throw new Exception($"unknown type {typ}");
    }

    public static string GetVersion() => "2.0.0-alpha.1";
    public static string GetProgram() => "cyamli";
    public static string GetDoc(List<string> subcommands) {
        switch (string.Join(" ", subcommands)) {
            case "":
                return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";
        
            case "generate":
                return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";
        
            case "generate dart3":
                return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate docs":
                return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate golang":
                return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate kotlin":
                return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate python3":
                return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate typescript":
                return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "version":
                return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n";
        default:
                throw new Exception($"invalid subcommands: {string.Join(", ", subcommands)}");
        }
    }
}

} // namespace

