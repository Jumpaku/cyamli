// Code generated by cyamli, DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.Linq;

namespace demo {

public interface ICliHandler {
    void Run(Cli.Input input);
    void Run_Data(Cli.Input_Data input);
    void Run_Schema(Cli.Input_Schema input);
    void Run_Tables(Cli.Input_Tables input);
    
}

public static class Cli {
    public static void Run(ICliHandler handler, string[] args) {
        var (subcommandPath, options, arguments) = ResolveArgs(args);
        switch (string.Join(" ", subcommandPath)) {
            
            case "":
                {
                    var input = new Input();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run(input);
                }
                break;
            
            case "data":
                {
                    var input = new Input_Data();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Data(input);
                }
                break;
            
            case "schema":
                {
                    var input = new Input_Schema();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Schema(input);
                }
                break;
            
            case "tables":
                {
                    var input = new Input_Tables();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Tables(input);
                }
                break;
            }
    }

    
    public class Input {
        public string Opt_Config = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-config":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Config = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_Data {
        public string Opt_Config = "";
        public string Opt_Where = "";
        public string Arg_Table = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-config":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Config = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-where":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Where = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            var expectedArgs = 1;
            
            
            if (this.Arguments.Count <= 0) {
                this.ErrorMessage = $"too few arguments: required {expectedArgs}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("string", this.Arguments.Skip(0).ToArray());
                this.Arg_Table = (string)v;
            } catch {
                this.ErrorMessage = $"value {this.Arguments[0]} is not assignable to argument at [0]";
                return;
            }
            
        }
    }
    
    public class Input_Schema {
        public string Opt_Config = "";
        public string Arg_Table = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-config":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Config = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            var expectedArgs = 1;
            
            
            if (this.Arguments.Count <= 0) {
                this.ErrorMessage = $"too few arguments: required {expectedArgs}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("string", this.Arguments.Skip(0).ToArray());
                this.Arg_Table = (string)v;
            } catch {
                this.ErrorMessage = $"value {this.Arguments[0]} is not assignable to argument at [0]";
                return;
            }
            
        }
    }
    
    public class Input_Tables {
        public string Opt_Config = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-config":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_Config = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    

    private static (List<string> subcommandPath, List<string> options, List<string> arguments) ResolveArgs(string[] args) {
        if (args.Length == 0) throw new Exception("command line arguments are too few");
        var subcommandSet = new HashSet<string> {
            "","data","schema","tables",
        };
        var subcommandPath = new List<string>();
        var options = new List<string>();
        var arguments = new List<string>();
        for (int i = 1; i < args.Length; i++) {
            if (args[i] == "--") break;
            var pathLiteral = string.Join(" ", subcommandPath.Concat(new[]{args[i]}));
            if (!subcommandSet.Contains(pathLiteral)) break;
            subcommandPath.Add(args[i]);
        }
        var restArgs = args.Skip(1 + subcommandPath.Count).ToArray();
        for (int idx = 0; idx < restArgs.Length; idx++) {
            var arg = restArgs[idx];
            if (arg == "--") {
                arguments.AddRange(restArgs.Skip(idx + 1));
                break;
            }
            if (arg.StartsWith("-")) options.Add(arg);
            else arguments.Add(arg);
        }
        return (subcommandPath, options, arguments);
    }

    private static object ParseValue(string typ, params string[] strValue) {
        switch (typ) {
            case "List<bool>":
                return strValue.Select(s => (bool)ParseValue("bool", s)).ToList();
            case "List<long>":
                return strValue.Select(s => (long)ParseValue("long", s)).ToList();
            case "List<string>":
                return strValue.Select(s => (string)ParseValue("string", s)).ToList();
            case "bool":
                switch (strValue[0].ToLower()) {
                    case "true": case "1": case "t": return true;
                    case "false": case "0": case "f": return false;
                    default: throw new Exception($"fail to parse {strValue[0]} as bool: unknown value");
                }
            case "long":
                return long.Parse(strValue[0]);
            case "string":
                return strValue[0];
        }
        throw new Exception($"unknown type {typ}");
    }

    public static string GetVersion() => "";
    public static string GetProgram() => "demo";
    public static string GetDoc(List<string> subcommands) {
        switch (string.Join(" ", subcommands)) {
            case "":
                return "demo \n\n    Syntax:\n        $ demo  [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Subcommands:\n        data:\n            dump data from the specified table from the database.\n\n        schema:\n            fetch schema of the specified table from the database.\n\n        tables:\n            list tables from the database.\n\n\n";
        
            case "data":
                return "demo data\n\n    Description:\n        dump data from the specified table from the database.\n\n    Syntax:\n        $ demo data [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n        -where=<string>  (default=\"\"):\n            filter data by the condition.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
        
            case "schema":
                return "demo schema\n\n    Description:\n        fetch schema of the specified table from the database.\n\n    Syntax:\n        $ demo schema [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
        
            case "tables":
                return "demo tables\n\n    Description:\n        list tables from the database.\n\n    Syntax:\n        $ demo tables [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n\n";
        default:
                throw new Exception($"invalid subcommands: {string.Join(", ", subcommands)}");
        }
    }
}

} // namespace

