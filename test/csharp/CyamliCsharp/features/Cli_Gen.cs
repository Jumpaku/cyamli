// Code generated by cyamli, DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.Linq;

namespace features {

public interface ICliHandler {
    void Run(Cli.Input input);
    void Run_Sub1(Cli.Input_Sub1 input);
    void Run_Sub1Sub2(Cli.Input_Sub1Sub2 input);
    void Run_Sub1Sub2Sub3(Cli.Input_Sub1Sub2Sub3 input);
    
}

public static class Cli {
    public static void Run(ICliHandler handler, string[] args) {
        var (subcommandPath, options, arguments) = ResolveArgs(args);
        switch (string.Join(" ", subcommandPath)) {
            
            case "":
                {
                    var input = new Input();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run(input);
                }
                break;
            
            case "sub1":
                {
                    var input = new Input_Sub1();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Sub1(input);
                }
                break;
            
            case "sub1 sub2":
                {
                    var input = new Input_Sub1Sub2();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Sub1Sub2(input);
                }
                break;
            
            case "sub1 sub2 sub3":
                {
                    var input = new Input_Sub1Sub2Sub3();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.Run_Sub1Sub2Sub3(input);
                }
                break;
            }
    }

    
    public class Input {
        public bool Opt_NegationOption = false;
        public long Opt_Option = 123L;
        public string Opt_PropagationOption = "";
        public List<long> Opt_RepeatableOption = new List<long>{};
        public bool Arg_FirstArg = false;
        public long Arg_SecondArg = 0L;
        public List<string> Arg_ThirdArg = new List<string>{};
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-negation-option":
                
                    {
                        if (lit == null) {
                            lit = "true";
                        }
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_NegationOption = (bool)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                case "-no-negation-option":
                    {
                        if (lit == null) lit = "true";
                        try {
                            var v = ParseValue("bool", lit);
                            this.Opt_NegationOption = !((bool)v);
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-option":
                case "-o":
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("long", lit);
                            this.Opt_Option = (long)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-propagation-option":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_PropagationOption = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                
                case "-repeatable-option":
                case "-r":
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("List<long>", lit);
                            if (this.Opt_RepeatableOption == null) this.Opt_RepeatableOption = new List<long>();
                            this.Opt_RepeatableOption.Add(((List<long>)v)[0]);
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            var expectedArgs = 3;
            
            
            if (this.Arguments.Count <= 0) {
                this.ErrorMessage = $"too few arguments: required {expectedArgs}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("bool", this.Arguments.Skip(0).ToArray());
                this.Arg_FirstArg = (bool)v;
            } catch {
                this.ErrorMessage = $"value {this.Arguments[0]} is not assignable to argument at [0]";
                return;
            }
            
            if (this.Arguments.Count <= 1) {
                this.ErrorMessage = $"too few arguments: required {expectedArgs}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("long", this.Arguments.Skip(1).ToArray());
                this.Arg_SecondArg = (long)v;
            } catch {
                this.ErrorMessage = $"value {this.Arguments[1]} is not assignable to argument at [1]";
                return;
            }
            
            if (this.Arguments.Count < 2) {
                this.ErrorMessage = $"too few arguments: required at least {expectedArgs-1}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("List<string>", this.Arguments.Skip(2).ToArray());
                this.Arg_ThirdArg = (List<string>)v;
            } catch {
                this.ErrorMessage = $"values [{string.Join(" ", this.Arguments.Skip(2))}] are not assignable to arguments at [2:]";
                return;
            }
            
        }
    }
    
    public class Input_Sub1 {
        public string Opt_PropagationOption = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-propagation-option":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_PropagationOption = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_Sub1Sub2 {
        public string Opt_PropagationOption = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-propagation-option":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_PropagationOption = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    
    public class Input_Sub1Sub2Sub3 {
        public string Opt_PropagationOption = "";
        
        public List<string> Subcommand = new List<string>{};
        public List<string> Options = new List<string>{};
        public List<string> Arguments = new List<string>{};
        public string? ErrorMessage = null;

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                case "-propagation-option":
                
                    {
                        if (lit == null) {
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                        }
                        try {
                            var v = ParseValue("string", lit);
                            this.Opt_PropagationOption = (string)v;
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }
            
            
        }
    }
    

    private static (List<string> subcommandPath, List<string> options, List<string> arguments) ResolveArgs(string[] args) {
        if (args.Length == 0) throw new Exception("command line arguments are too few");
        var subcommandSet = new HashSet<string> {
            "","sub1","sub1 sub2","sub1 sub2 sub3",
        };
        var subcommandPath = new List<string>();
        var options = new List<string>();
        var arguments = new List<string>();
        for (int i = 1; i < args.Length; i++) {
            if (args[i] == "--") break;
            var pathLiteral = string.Join(" ", subcommandPath.Concat(new[]{args[i]}));
            if (!subcommandSet.Contains(pathLiteral)) break;
            subcommandPath.Add(args[i]);
        }
        var restArgs = args.Skip(1 + subcommandPath.Count).ToArray();
        for (int idx = 0; idx < restArgs.Length; idx++) {
            var arg = restArgs[idx];
            if (arg == "--") {
                arguments.AddRange(restArgs.Skip(idx + 1));
                break;
            }
            if (arg.StartsWith("-")) options.Add(arg);
            else arguments.Add(arg);
        }
        return (subcommandPath, options, arguments);
    }

    private static object ParseValue(string typ, params string[] strValue) {
        switch (typ) {
            case "List<bool>":
                return strValue.Select(s => (bool)ParseValue("bool", s)).ToList();
            case "List<long>":
                return strValue.Select(s => (long)ParseValue("long", s)).ToList();
            case "List<string>":
                return strValue.Select(s => (string)ParseValue("string", s)).ToList();
            case "bool":
                switch (strValue[0].ToLower()) {
                    case "true": case "1": case "t": return true;
                    case "false": case "0": case "f": return false;
                    default: throw new Exception($"fail to parse {strValue[0]} as bool: unknown value");
                }
            case "long":
                return long.Parse(strValue[0]);
            case "string":
                return strValue[0];
        }
        throw new Exception($"unknown type {typ}");
    }

    public static string GetVersion() => "1.2.3";
    public static string GetProgram() => "features";
    public static string GetDoc(List<string> subcommands) {
        switch (string.Join(" ", subcommands)) {
            case "":
                return "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        $ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>](default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>(default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<integer> ... , -r=<integer> ... :\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n";
        
            case "sub1":
                return "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        $ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n";
        
            case "sub1 sub2":
                return "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n";
        
            case "sub1 sub2 sub3":
                return "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n\n";
        default:
                throw new Exception($"invalid subcommands: {string.Join(", ", subcommands)}");
        }
    }
}

} // namespace

