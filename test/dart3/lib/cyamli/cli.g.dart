// Code generated by cyamli, DO NOT EDIT.
// ignore_for_file: non_constant_identifier_names

/// Interface for CLI handlers
abstract class CLIHandler {
  Future<void> Run(Input input);
  Future<void> Run_Generate(Input_Generate input);
  Future<void> Run_GenerateDart3(Input_GenerateDart3 input);
  Future<void> Run_GenerateDocs(Input_GenerateDocs input);
  Future<void> Run_GenerateGolang(Input_GenerateGolang input);
  Future<void> Run_GenerateKotlin(Input_GenerateKotlin input);
  Future<void> Run_GeneratePython3(Input_GeneratePython3 input);
  Future<void> Run_GenerateTypescript(Input_GenerateTypescript input);
  Future<void> Run_Version(Input_Version input);
}

/// Entry point for the CLI application
Future<void> run(CLIHandler handler, List<String> args) async {
  final (path, options, arguments) = resolveSubcommand(args);
  final subcommandPath = path;

  switch (subcommandPath.join(' ')) {
  case "":
    final input = Input();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run(input);
    break;
  case "generate":
    final input = Input_Generate();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_Generate(input);
    break;
  case "generate dart3":
    final input = Input_GenerateDart3();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GenerateDart3(input);
    break;
  case "generate docs":
    final input = Input_GenerateDocs();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GenerateDocs(input);
    break;
  case "generate golang":
    final input = Input_GenerateGolang();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GenerateGolang(input);
    break;
  case "generate kotlin":
    final input = Input_GenerateKotlin();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GenerateKotlin(input);
    break;
  case "generate python3":
    final input = Input_GeneratePython3();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GeneratePython3(input);
    break;
  case "generate typescript":
    final input = Input_GenerateTypescript();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_GenerateTypescript(input);
    break;
  case "version":
    final input = Input_Version();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_Version(input);
    break;
  }
}


/// Input class for Run
class Input {bool Opt_Help = false;
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_Generate
class Input_Generate {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GenerateDart3
class Input_GenerateDart3 {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GenerateDocs
class Input_GenerateDocs {String Opt_Format = "text";
  bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Format: $Opt_Format');
      buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-format', '-f'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Format = v;
        continue;
      }
      
      
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GenerateGolang
class Input_GenerateGolang {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_Package = "main";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_Package: $Opt_Package');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-package'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Package = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GenerateKotlin
class Input_GenerateKotlin {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_Package = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_Package: $Opt_Package');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-package'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Package = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GeneratePython3
class Input_GeneratePython3 {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_GenerateTypescript
class Input_GenerateTypescript {bool Opt_Help = false;
  String Opt_OutPath = "";
  String Opt_SchemaPath = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      buffer.writeln('Opt_OutPath: $Opt_OutPath');
      buffer.writeln('Opt_SchemaPath: $Opt_SchemaPath');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      
      if (['-out-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_OutPath = v;
        continue;
      }
      
      
      if (['-schema-path'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_SchemaPath = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_Version
class Input_Version {bool Opt_Help = false;
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_Help: $Opt_Help');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-help', '-h'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Help = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}
/// Resolves the subcommand from the arguments
(List<String> subcommandPath, List<String> options, List<String> arguments) resolveSubcommand(List<String> args) {
  final subcommandSet = {
    "": true,  "generate": true,  "generate dart3": true,  "generate docs": true,  "generate golang": true,  "generate kotlin": true,  "generate python3": true,  "generate typescript": true,  "version": true,
  };

  final subcommandPath = <String>[];

  for (final arg in args) {
    if (arg == '--') {
      break;
    }
    final pathLiteral = [...subcommandPath, arg].join(' ');
    if (!subcommandSet.containsKey(pathLiteral)) {
      break;
    }
    subcommandPath.add(arg);
  }

  final restArgs = args.sublist(subcommandPath.length);
  final options = <String>[];
  final arguments = <String>[];
  for (int idx = 0; idx < restArgs.length; idx++) {
    final arg = restArgs[idx];
    if (arg == '--') {
      arguments.addAll(restArgs.sublist(idx + 1));
      break;
    }
    if (arg.startsWith('-')) {
      options.add(arg);
    } else {
      arguments.add(arg);
    }
  }

  return (subcommandPath, options, arguments);
}

/// Parses a string value to the specified type
dynamic parseValue(String strValue, String typeName) {
  switch (typeName) {
    case 'List<bool>':
      return parseValue(strValue, 'bool') as bool;
    case 'List<int>':
      return parseValue(strValue, 'int') as int;
    case 'List<String>':
      return parseValue(strValue, 'String') as String;
    case 'bool':
      if (['true', 't', '1'].contains(strValue.toLowerCase())) return true;
      if (['false', 'f', '0'].contains(strValue.toLowerCase())) return false;
      throw FormatException('Failed to parse "$strValue" as bool');
    case 'int':
      try {
        return int.parse(strValue);
      } catch (e) {
        throw FormatException('Failed to parse "$strValue" as int');
      }
    case 'String':
      return strValue;
    default:
      throw FormatException('Unsupported type: $typeName');
  }
}
/// Parses a string values to the specified type
List<dynamic> parseValues(List<String> strValue, String typeName) {
  switch (typeName) {
    case 'List<bool>':
      return strValue.map((s) => parseValue(s, 'bool') as bool).toList();
    case 'List<int>':
      return strValue.map((s) => parseValue(s, 'int') as int).toList();
    case 'List<String>':
      return strValue.map((s) => parseValue(s, 'String') as String).toList();
    default:
      throw FormatException('Unsupported type: $typeName');
  }
}

/// Returns the version of the program.
String getVersion() {
  return '2.0.0-alpha.1';
}
/// Returns the program name.
String getProgram() {
  return 'cyamli';
}

/// Gets documentation for a subcommand
String getDoc(List<String> subcommands) {
  switch (subcommands.join(' ')) {
    case "":
      return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        \$ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";
  
    case "generate":
      return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        \$ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";
  
    case "generate dart3":
      return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        \$ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "generate docs":
      return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        \$ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "generate golang":
      return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        \$ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "generate kotlin":
      return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        \$ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "generate python3":
      return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        \$ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "generate typescript":
      return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        \$ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
  
    case "version":
      return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        \$ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n";
  default:
      throw Exception('Invalid subcommands: $subcommands');
  }
}
