// Code generated by cyamli, DO NOT EDIT.
// ignore_for_file: non_constant_identifier_names

/// Interface for CLI handlers
abstract class CLIHandler {
  Future<void> Run(Input input);
  Future<void> Run_Sub1(Input_Sub1 input);
  Future<void> Run_Sub1Sub2(Input_Sub1Sub2 input);
  Future<void> Run_Sub1Sub2Sub3(Input_Sub1Sub2Sub3 input);
}

/// Entry point for the CLI application
Future<void> run(CLIHandler handler, List<String> args) async {
  final (path, options, arguments) = resolveSubcommand(args);
  final subcommandPath = path;

  switch (subcommandPath.join(' ')) {
  case "":
    final input = Input();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run(input);
    break;
  case "sub1":
    final input = Input_Sub1();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_Sub1(input);
    break;
  case "sub1 sub2":
    final input = Input_Sub1Sub2();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_Sub1Sub2(input);
    break;
  case "sub1 sub2 sub3":
    final input = Input_Sub1Sub2Sub3();
    input.resolveInput(subcommandPath, options, arguments);
    await handler.Run_Sub1Sub2Sub3(input);
    break;
  }
}


/// Input class for Run
class Input {bool Opt_NegationOption = false;
  int Opt_Option = 123;
  String Opt_PropagationOption = "";
  String Opt_RepeatableOption = "";
  bool? Arg_FirstArg;
  int? Arg_SecondArg;
  List<String>? Arg_ThirdArg;
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_NegationOption: $Opt_NegationOption');
      buffer.writeln('Opt_Option: $Opt_Option');
      buffer.writeln('Opt_PropagationOption: $Opt_PropagationOption');
      buffer.writeln('Opt_RepeatableOption: $Opt_RepeatableOption');
      buffer.writeln('Arg_FirstArg: $Arg_FirstArg');
      buffer.writeln('Arg_SecondArg: $Arg_SecondArg');
      buffer.writeln('Arg_ThirdArg: $Arg_ThirdArg');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-negation-option'].contains(optName)) {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_NegationOption = v;
        continue;
      }
      if (optName == '-no-negation-option') {
        if (cut < 0) {
          lit = 'true';
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'bool');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_NegationOption = !(v as bool);
        continue;
      }
      
      if (['-option', '-o'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'int');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_Option = v;
        continue;
      }
      
      
      if (['-propagation-option'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_PropagationOption = v;
        continue;
      }
      
      
      if (['-repeatable-option'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_RepeatableOption = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 3;

    
    if (arguments.length <= 0) {
      errorMessage = 'Too few arguments: required $expectedArgs, got ${arguments.length}';
      return;
    }
    try {
      Arg_FirstArg = parseValue(arguments[0], 'bool');
    } catch (e) {
      errorMessage = 'Value "${arguments[0]}" is not assignable to argument at [0]';
      return;
    }
    
    if (arguments.length <= 1) {
      errorMessage = 'Too few arguments: required $expectedArgs, got ${arguments.length}';
      return;
    }
    try {
      Arg_SecondArg = parseValue(arguments[1], 'int');
    } catch (e) {
      errorMessage = 'Value "${arguments[1]}" is not assignable to argument at [1]';
      return;
    }
    
    if (arguments.length < 2) {
      errorMessage = 'Too few arguments: required at least ${expectedArgs - 1}, got ${arguments.length}';
      return;
    }
    try {
      Arg_ThirdArg = parseValues(arguments.sublist(2), 'List<String>') as List<String>;
    } catch (e) {
      errorMessage = 'Values [${arguments.sublist(2).join(" ")}] are not assignable to arguments at [2:]';
      return;
    }
    }
}

/// Input class for Run_Sub1
class Input_Sub1 {String Opt_PropagationOption = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_PropagationOption: $Opt_PropagationOption');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-propagation-option'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_PropagationOption = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_Sub1Sub2
class Input_Sub1Sub2 {String Opt_PropagationOption = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_PropagationOption: $Opt_PropagationOption');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-propagation-option'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_PropagationOption = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}

/// Input class for Run_Sub1Sub2Sub3
class Input_Sub1Sub2Sub3 {String Opt_PropagationOption = "";
  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');buffer.writeln('Opt_PropagationOption: $Opt_PropagationOption');
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> subcommand, List<String> options, List<String> arguments) {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = arguments;

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }
      if (['-propagation-option'].contains(optName)) {
        if (cut < 0) {
          errorMessage = 'Value is not specified to option "$optName"';
          return;
        }
        dynamic v;
        try {
          v = parseValue(lit!, 'String');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        Opt_PropagationOption = v;
        continue;
      }
      
      errorMessage = 'Unknown option "$optName"';
      return;
    }

    final expectedArgs = 0;

    }
}
/// Resolves the subcommand from the arguments
(List<String> subcommandPath, List<String> options, List<String> arguments) resolveSubcommand(List<String> args) {
  final subcommandSet = {
    "": true,  "sub1": true,  "sub1 sub2": true,  "sub1 sub2 sub3": true,
  };

  final subcommandPath = <String>[];

  for (final arg in args) {
    if (arg == '--') {
      break;
    }
    final pathLiteral = [...subcommandPath, arg].join(' ');
    if (!subcommandSet.containsKey(pathLiteral)) {
      break;
    }
    subcommandPath.add(arg);
  }

  final restArgs = args.sublist(subcommandPath.length);
  final options = <String>[];
  final arguments = <String>[];
  for (int idx = 0; idx < restArgs.length; idx++) {
    final arg = restArgs[idx];
    if (arg == '--') {
      arguments.addAll(restArgs.sublist(idx + 1));
      break;
    }
    if (arg.startsWith('-')) {
      options.add(arg);
    } else {
      arguments.add(arg);
    }
  }

  return (subcommandPath, options, arguments);
}

/// Parses a string value to the specified type
dynamic parseValue(String strValue, String typeName) {
  switch (typeName) {
    case 'List<bool>':
      return parseValue(strValue, 'bool') as bool;
    case 'List<int>':
      return parseValue(strValue, 'int') as int;
    case 'List<String>':
      return parseValue(strValue, 'String') as String;
    case 'bool':
      if (['true', 't', '1'].contains(strValue.toLowerCase())) return true;
      if (['false', 'f', '0'].contains(strValue.toLowerCase())) return false;
      throw FormatException('Failed to parse "$strValue" as bool');
    case 'int':
      try {
        return int.parse(strValue);
      } catch (e) {
        throw FormatException('Failed to parse "$strValue" as int');
      }
    case 'String':
      return strValue;
    default:
      throw FormatException('Unsupported type: $typeName');
  }
}
/// Parses a string values to the specified type
List<dynamic> parseValues(List<String> strValue, String typeName) {
  switch (typeName) {
    case 'List<bool>':
      return strValue.map((s) => parseValue(s, 'bool') as bool).toList();
    case 'List<int>':
      return strValue.map((s) => parseValue(s, 'int') as int).toList();
    case 'List<String>':
      return strValue.map((s) => parseValue(s, 'String') as String).toList();
    default:
      throw FormatException('Unsupported type: $typeName');
  }
}

/// Returns the version of the program.
String getVersion() {
  return '1.2.3';
}
/// Returns the program name.
String getProgram() {
  return 'features';
}

/// Gets documentation for a subcommand
String getDoc(List<String> subcommands) {
  switch (subcommands.join(' ')) {
    case "":
      return "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        \$ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>]  (default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>  (default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<string>  (default=\"\"):\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n";
  
    case "sub1":
      return "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        \$ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n";
  
    case "sub1 sub2":
      return "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        \$ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n";
  
    case "sub1 sub2 sub3":
      return "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        \$ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n\n";
  default:
      throw Exception('Invalid subcommands: $subcommands');
  }
}
