// Code generated by cyamli, DO NOT EDIT.
package cyamli_test

import (
	. "cyamli/test/golang/cyamli"
	"github.com/stretchr/testify/assert"
	"testing"
)

type CLIHandlerMock struct {
	GotInput any
}

var _ CLIHandler = (*CLIHandlerMock)(nil)

func (m *CLIHandlerMock) Run(input Input) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_Generate(input Input_Generate) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GenerateDart3(input Input_GenerateDart3) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GenerateDocs(input Input_GenerateDocs) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GenerateGolang(input Input_GenerateGolang) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GenerateKotlin(input Input_GenerateKotlin) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GeneratePython3(input Input_GeneratePython3) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_GenerateTypescript(input Input_GenerateTypescript) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_Version(input Input_Version) error {
	m.GotInput = input
	return nil
}

func TestRun(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"",
				"-help=0",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
		{
			name: "default-options",
			args: []string{
				"",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
		{
			name: "short-options",
			args: []string{
				"",
				"-h=0",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
		{
			name: "negated-options",
			args: []string{
				"",
				"-help=0",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"",
				"-help=0",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"",
				"-help=0",
				"--",
			},
			wantInput: Input{
				Opt_Help: false,
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")

		})
	}
}

func TestRun_Generate(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_Generate
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate",
				"-h=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_Generate{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_Generate)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GenerateDart3(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GenerateDart3
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "dart3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "dart3",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "dart3",
				"-h=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "dart3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "dart3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "dart3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDart3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GenerateDart3)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GenerateDocs(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GenerateDocs
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "docs",
				"-format=0",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "0",
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "docs",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "text",
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "docs",
				"-f=0",
				"-h=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "0",
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "docs",
				"-format=0",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "0",
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "docs",
				"-format=0",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "0",
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "docs",
				"-format=0",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateDocs{
				Opt_Format:     "0",
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GenerateDocs)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Format, got.Opt_Format, "unexpected input for option: %s", "-format")
			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GenerateGolang(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GenerateGolang
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "golang",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "golang",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_Package:    "main",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "golang",
				"-h=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "golang",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "golang",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "golang",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateGolang{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GenerateGolang)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_Package, got.Opt_Package, "unexpected input for option: %s", "-package")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GenerateKotlin(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GenerateKotlin
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "kotlin",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "kotlin",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_Package:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "kotlin",
				"-h=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "kotlin",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "kotlin",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "kotlin",
				"-help=0",
				"-out-path=0",
				"-package=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateKotlin{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_Package:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GenerateKotlin)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_Package, got.Opt_Package, "unexpected input for option: %s", "-package")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GeneratePython3(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GeneratePython3
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "python3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "python3",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "python3",
				"-h=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "python3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "python3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "python3",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GeneratePython3{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GeneratePython3)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_GenerateTypescript(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_GenerateTypescript
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "generate", "typescript",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "generate", "typescript",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "",
				Opt_SchemaPath: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "generate", "typescript",
				"-h=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "generate", "typescript",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "generate", "typescript",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "generate", "typescript",
				"-help=0",
				"-out-path=0",
				"-schema-path=0",
				"--",
			},
			wantInput: Input_GenerateTypescript{
				Opt_Help:       false,
				Opt_OutPath:    "0",
				Opt_SchemaPath: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_GenerateTypescript)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")
			assert.Equal(t, want.Opt_OutPath, got.Opt_OutPath, "unexpected input for option: %s", "-out-path")
			assert.Equal(t, want.Opt_SchemaPath, got.Opt_SchemaPath, "unexpected input for option: %s", "-schema-path")

		})
	}
}

func TestRun_Version(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_Version
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "version",
				"-help=0",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "version",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "version",
				"-h=0",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "version",
				"-help=0",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "version",
				"-help=0",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "version",
				"-help=0",
				"--",
			},
			wantInput: Input_Version{
				Opt_Help: false,
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_Version)
			want := tc.wantInput

			assert.Equal(t, want.Opt_Help, got.Opt_Help, "unexpected input for option: %s", "-help")

		})
	}
}
