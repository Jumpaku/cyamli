// Code generated by cyamli, DO NOT EDIT.
package features_test

import (
	. "cyamli/test/golang/features"
	"github.com/stretchr/testify/assert"
	"testing"
)

type CLIHandlerMock struct {
	GotInput any
}

var _ CLIHandler = (*CLIHandlerMock)(nil)

func (m *CLIHandlerMock) Run(input Input) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_Sub1(input Input_Sub1) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_Sub1Sub2(input Input_Sub1Sub2) error {
	m.GotInput = input
	return nil
}
func (m *CLIHandlerMock) Run_Sub1Sub2Sub3(input Input_Sub1Sub2Sub3) error {
	m.GotInput = input
	return nil
}

func TestRun(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"",
				"-negation-option=0",
				"-option=0",
				"-propagation-option=0",
				"-repeatable-option=0",
				"--",
				"0",
				"0",
				"0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            0,
				Opt_PropagationOption: "0",
				Opt_RepeatableOption:  "0",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{"0"},
			},
		},
		{
			name: "default-options",
			args: []string{
				"",
				"--",
				"0",
				"0",
				"0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            123,
				Opt_PropagationOption: "",
				Opt_RepeatableOption:  "",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{"0"},
			},
		},
		{
			name: "short-options",
			args: []string{
				"",
				"-negation-option=0",
				"-o=0",
				"-propagation-option=0",
				"-repeatable-option=0",
				"--",
				"0",
				"0",
				"0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            0,
				Opt_PropagationOption: "0",
				Opt_RepeatableOption:  "0",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{"0"},
			},
		},
		{
			name: "negated-options",
			args: []string{
				"",
				"-no-negation-option=1",
				"-option=0",
				"-propagation-option=0",
				"-repeatable-option=0",
				"--",
				"0",
				"0",
				"0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            0,
				Opt_PropagationOption: "0",
				Opt_RepeatableOption:  "0",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{"0"},
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"",
				"-no-negation-option=1",
				"-option=0",
				"-propagation-option=0",
				"-repeatable-option=0",
				"--",
				"0",
				"0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            0,
				Opt_PropagationOption: "0",
				Opt_RepeatableOption:  "0",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{},
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"",
				"-no-negation-option=1",
				"-option=0",
				"-propagation-option=0",
				"-repeatable-option=0",
				"--",
				"0",
				"0",
				"0", "0",
			},
			wantInput: Input{
				Opt_NegationOption:    false,
				Opt_Option:            0,
				Opt_PropagationOption: "0",
				Opt_RepeatableOption:  "0",
				Arg_FirstArg:          false,
				Arg_SecondArg:         0,
				Arg_ThirdArg:          []string{"0", "0"},
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input)
			want := tc.wantInput

			assert.Equal(t, want.Opt_NegationOption, got.Opt_NegationOption, "unexpected input for option: %s", "-negation-option")
			assert.Equal(t, want.Opt_Option, got.Opt_Option, "unexpected input for option: %s", "-option")
			assert.Equal(t, want.Opt_PropagationOption, got.Opt_PropagationOption, "unexpected input for option: %s", "-propagation-option")
			assert.Equal(t, want.Opt_RepeatableOption, got.Opt_RepeatableOption, "unexpected input for option: %s", "-repeatable-option")

			assert.Equal(t, want.Arg_FirstArg, got.Arg_FirstArg, "unexpected input for argument: %s", "first_arg")
			assert.Equal(t, want.Arg_SecondArg, got.Arg_SecondArg, "unexpected input for argument: %s", "second_arg")
			assert.Equal(t, want.Arg_ThirdArg, got.Arg_ThirdArg, "unexpected input for argument: %s", "third_arg")
		})
	}
}

func TestRun_Sub1(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_Sub1
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "sub1",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "sub1",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "sub1",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "sub1",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "sub1",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "sub1",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1{
				Opt_PropagationOption: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_Sub1)
			want := tc.wantInput

			assert.Equal(t, want.Opt_PropagationOption, got.Opt_PropagationOption, "unexpected input for option: %s", "-propagation-option")

		})
	}
}

func TestRun_Sub1Sub2(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_Sub1Sub2
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "sub1", "sub2",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "sub1", "sub2",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "sub1", "sub2",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "sub1", "sub2",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "sub1", "sub2",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "sub1", "sub2",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2{
				Opt_PropagationOption: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_Sub1Sub2)
			want := tc.wantInput

			assert.Equal(t, want.Opt_PropagationOption, got.Opt_PropagationOption, "unexpected input for option: %s", "-propagation-option")

		})
	}
}

func TestRun_Sub1Sub2Sub3(t *testing.T) {
	testcases := []struct {
		name      string
		args      []string
		wantInput Input_Sub1Sub2Sub3
	}{
		{
			name: "command-line-arguments",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "default-options",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "",
			},
		},
		{
			name: "short-options",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "negated-options",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-zero",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "0",
			},
		},
		{
			name: "variadic-arguments-two",
			args: []string{
				"", "sub1", "sub2", "sub3",
				"-propagation-option=0",
				"--",
			},
			wantInput: Input_Sub1Sub2Sub3{
				Opt_PropagationOption: "0",
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.name, func(t *testing.T) {
			mock := &CLIHandlerMock{}
			err := Run(mock, tc.args)
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			got := mock.GotInput.(Input_Sub1Sub2Sub3)
			want := tc.wantInput

			assert.Equal(t, want.Opt_PropagationOption, got.Opt_PropagationOption, "unexpected input for option: %s", "-propagation-option")

		})
	}
}
