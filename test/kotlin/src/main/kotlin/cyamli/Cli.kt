// Code generated by cyamli, DO NOT EDIT.
package cyamli

// Interface for CLI handlers
interface CLIHandler {

    fun execute(input: Input)

    fun execute_Generate(input: Input_Generate)

    fun execute_GenerateDart3(input: Input_GenerateDart3)

    fun execute_GenerateDocs(input: Input_GenerateDocs)

    fun execute_GenerateGolang(input: Input_GenerateGolang)

    fun execute_GenerateKotlin(input: Input_GenerateKotlin)

    fun execute_GeneratePython3(input: Input_GeneratePython3)

    fun execute_GenerateTypescript(input: Input_GenerateTypescript)

    fun execute_Version(input: Input_Version)

}

// Entry point for the CLI application
fun execute(handler: CLIHandler, args: Array<String>) {
    val (subcommandPath, options, arguments) = resolveSubcommand(args)

    when (subcommandPath.joinToString(" ")) {

        "" -> {
            val input = Input()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute(input)
        }

        "generate" -> {
            val input = Input_Generate()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Generate(input)
        }

        "generate dart3" -> {
            val input = Input_GenerateDart3()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GenerateDart3(input)
        }

        "generate docs" -> {
            val input = Input_GenerateDocs()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GenerateDocs(input)
        }

        "generate golang" -> {
            val input = Input_GenerateGolang()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GenerateGolang(input)
        }

        "generate kotlin" -> {
            val input = Input_GenerateKotlin()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GenerateKotlin(input)
        }

        "generate python3" -> {
            val input = Input_GeneratePython3()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GeneratePython3(input)
        }

        "generate typescript" -> {
            val input = Input_GenerateTypescript()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_GenerateTypescript(input)
        }

        "version" -> {
            val input = Input_Version()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Version(input)
        }

        else -> {}
    }
}


// Input class for execute
data class Input(

    var opt_Help: Boolean = false,



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_Generate
data class Input_Generate(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GenerateDart3
data class Input_GenerateDart3(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GenerateDocs
data class Input_GenerateDocs(

    var opt_Format: String = "text",

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-format", "-f" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Format = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GenerateGolang
data class Input_GenerateGolang(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_Package: String = "main",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-package" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Package = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GenerateKotlin
data class Input_GenerateKotlin(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_Package: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-package" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Package = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GeneratePython3
data class Input_GeneratePython3(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_GenerateTypescript
data class Input_GenerateTypescript(

    var opt_Help: Boolean = false,

    var opt_OutPath: String = "",

    var opt_SchemaPath: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-out-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_OutPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-schema-path" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_SchemaPath = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_Version
data class Input_Version(

    var opt_Help: Boolean = false,



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-help", "-h" -> {
                    if (!hasValue) {
                        opt_Help = true
                    } else {
                        try {
                            opt_Help = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}


// Resolves the subcommand from arguments
internal fun resolveSubcommand(args: Array<String>): Triple<List<String>, List<String>, List<String>> {
    val subcommandSet = mapOf(

        "" to true,

        "generate" to true,

        "generate dart3" to true,

        "generate docs" to true,

        "generate golang" to true,

        "generate kotlin" to true,

        "generate python3" to true,

        "generate typescript" to true,

        "version" to true,

    )

    val subcommandPath = mutableListOf<String>()

    for (arg in args) {
        if (arg == "--") {
            break
        }
        val pathLiteral = (subcommandPath + arg).joinToString(" ")
        if (!subcommandSet.containsKey(pathLiteral)) {
            break
        }
        subcommandPath.add(arg)
    }

    val restArgs = args.drop(subcommandPath.size)
    val options = mutableListOf<String>()
    val arguments = mutableListOf<String>()
    var idx = 0
    while (idx < restArgs.size) {
        val arg = restArgs[idx]
        if (arg == "--") {
            arguments.addAll(restArgs.subList(idx + 1, restArgs.size))
            break
        }
        if (arg.startsWith("-")) {
            options.add(arg)
        } else {
            arguments.add(arg)
        }
        idx++
    }

    return Triple(subcommandPath, options, arguments)
}

// Parses a string value to Boolean
internal fun parseBoolean(strValue: String): Boolean {
    return when(strValue) {
        "true", "1", "t" -> true
        "false", "0", "f" -> false
        else -> throw IllegalArgumentException("Invalid boolean value: $strValue")
    }
}

// Parses a string value to Long
internal fun parseLong(strValue: String): Long {
    return strValue.toLong()
}

// Parses a string value to String
internal fun parseString(strValue: String): String {
    return strValue
}

// Parses a list of string values to a list of Boolean
internal fun parseArrayBoolean(strValues: List<String>): List<Boolean> {
    return strValues.map { parseBoolean(it) }
}

// Parses a list of string values to a list of Long
internal fun parseArrayLong(strValues: List<String>): List<Long> {
    return strValues.map { parseLong(it) }
}

// Parses a list of string values to a list of String
internal fun parseArrayString(strValues: List<String>): List<String> {
    return strValues.map { parseString(it) }
}
fun getVersion(): String {
    return "2.0.0-alpha.1"
}
fun getProgram(): String {
    return "cyamli"
}
// Gets documentation for a subcommand
fun getDoc(subcommands: List<String>): String {
    return when (subcommands.joinToString(" ")) {

        "" -> "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n"

        "generate" -> "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n"

        "generate dart3" -> "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "generate docs" -> "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "generate golang" -> "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "generate kotlin" -> "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "generate python3" -> "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "generate typescript" -> "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

        "version" -> "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n"

        else -> throw IllegalArgumentException("Invalid subcommands: $subcommands")
    }
}
