// Code generated by cyamli, DO NOT EDIT.
package demo

// Interface for CLI handlers
interface CLIHandler {

    fun execute(input: Input)

    fun execute_Data(input: Input_Data)

    fun execute_Schema(input: Input_Schema)

    fun execute_Tables(input: Input_Tables)

}

// Entry point for the CLI application
fun execute(handler: CLIHandler, args: Array<String>) {
    val (subcommandPath, options, arguments) = resolveSubcommand(args)

    when (subcommandPath.joinToString(" ")) {

        "" -> {
            val input = Input()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute(input)
        }

        "data" -> {
            val input = Input_Data()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Data(input)
        }

        "schema" -> {
            val input = Input_Schema()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Schema(input)
        }

        "tables" -> {
            val input = Input_Tables()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Tables(input)
        }

        else -> {}
    }
}


// Input class for execute
data class Input(

    var opt_Config: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-config" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Config = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_Data
data class Input_Data(

    var opt_Config: String = "",

    var opt_Where: String = "",


    var arg_Table: String = "",


    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-config" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Config = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-where" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Where = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        val expectedArgs = 1

    
        if (arguments.size <= 0) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            arg_Table = parseString(arguments[0])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[0]}\" is not assignable to argument at [0]"
            return
        }
    
    }
}

// Input class for execute_Schema
data class Input_Schema(

    var opt_Config: String = "",


    var arg_Table: String = "",


    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-config" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Config = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        val expectedArgs = 1

    
        if (arguments.size <= 0) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            arg_Table = parseString(arguments[0])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[0]}\" is not assignable to argument at [0]"
            return
        }
    
    }
}

// Input class for execute_Tables
data class Input_Tables(

    var opt_Config: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-config" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Config = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}


// Resolves the subcommand from arguments
internal fun resolveSubcommand(args: Array<String>): Triple<List<String>, List<String>, List<String>> {
    val subcommandSet = mapOf(

        "" to true,

        "data" to true,

        "schema" to true,

        "tables" to true,

    )

    val subcommandPath = mutableListOf<String>()

    for (arg in args) {
        if (arg == "--") {
            break
        }
        val pathLiteral = (subcommandPath + arg).joinToString(" ")
        if (!subcommandSet.containsKey(pathLiteral)) {
            break
        }
        subcommandPath.add(arg)
    }

    val restArgs = args.drop(subcommandPath.size)
    val options = mutableListOf<String>()
    val arguments = mutableListOf<String>()
    var idx = 0
    while (idx < restArgs.size) {
        val arg = restArgs[idx]
        if (arg == "--") {
            arguments.addAll(restArgs.subList(idx + 1, restArgs.size))
            break
        }
        if (arg.startsWith("-")) {
            options.add(arg)
        } else {
            arguments.add(arg)
        }
        idx++
    }

    return Triple(subcommandPath, options, arguments)
}

// Parses a string value to Boolean
internal fun parseBoolean(strValue: String): Boolean {
    return when(strValue) {
        "true", "1", "t" -> true
        "false", "0", "f" -> false
        else -> throw IllegalArgumentException("Invalid boolean value: $strValue")
    }
}

// Parses a string value to Long
internal fun parseLong(strValue: String): Long {
    return strValue.toLong()
}

// Parses a string value to String
internal fun parseString(strValue: String): String {
    return strValue
}

// Parses a list of string values to a list of Boolean
internal fun parseArrayBoolean(strValues: List<String>): List<Boolean> {
    return strValues.map { parseBoolean(it) }
}

// Parses a list of string values to a list of Long
internal fun parseArrayLong(strValues: List<String>): List<Long> {
    return strValues.map { parseLong(it) }
}

// Parses a list of string values to a list of String
internal fun parseArrayString(strValues: List<String>): List<String> {
    return strValues.map { parseString(it) }
}
fun getVersion(): String {
    return ""
}
fun getProgram(): String {
    return "demo"
}
// Gets documentation for a subcommand
fun getDoc(subcommands: List<String>): String {
    return when (subcommands.joinToString(" ")) {

        "" -> "demo \n\n    Syntax:\n        $ demo  [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Subcommands:\n        data:\n            dump data from the specified table from the database.\n\n        schema:\n            fetch schema of the specified table from the database.\n\n        tables:\n            list tables from the database.\n\n\n"

        "data" -> "demo data\n\n    Description:\n        dump data from the specified table from the database.\n\n    Syntax:\n        $ demo data [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n        -where=<string>  (default=\"\"):\n            filter data by the condition.\n\n    Arguments:\n        1.  <table:string>\n\n\n"

        "schema" -> "demo schema\n\n    Description:\n        fetch schema of the specified table from the database.\n\n    Syntax:\n        $ demo schema [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Arguments:\n        1.  <table:string>\n\n\n"

        "tables" -> "demo tables\n\n    Description:\n        list tables from the database.\n\n    Syntax:\n        $ demo tables [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n\n"

        else -> throw IllegalArgumentException("Invalid subcommands: $subcommands")
    }
}
