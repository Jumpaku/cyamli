// Code generated by cyamli, DO NOT EDIT.
package features

// Interface for CLI handlers
interface CLIHandler {

    fun execute(input: Input)

    fun execute_Sub1(input: Input_Sub1)

    fun execute_Sub1Sub2(input: Input_Sub1Sub2)

    fun execute_Sub1Sub2Sub3(input: Input_Sub1Sub2Sub3)

}

// Entry point for the CLI application
fun execute(handler: CLIHandler, args: Array<String>) {
    val (subcommandPath, options, arguments) = resolveSubcommand(args)

    when (subcommandPath.joinToString(" ")) {

        "" -> {
            val input = Input()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute(input)
        }

        "sub1" -> {
            val input = Input_Sub1()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Sub1(input)
        }

        "sub1 sub2" -> {
            val input = Input_Sub1Sub2()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Sub1Sub2(input)
        }

        "sub1 sub2 sub3" -> {
            val input = Input_Sub1Sub2Sub3()
            input.resolveInput(subcommandPath, options, arguments)
            handler.execute_Sub1Sub2Sub3(input)
        }

        else -> {}
    }
}


// Input class for execute
data class Input(

    var opt_NegationOption: Boolean = false,

    var opt_Option: Long = 123L,

    var opt_PropagationOption: String = "",

    var opt_RepeatableOption: String = "",


    var arg_FirstArg: Boolean = false,

    var arg_SecondArg: Long = 0L,

    var arg_ThirdArg: List<String> = listOf(),


    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-negation-option" -> {
                    if (!hasValue) {
                        opt_NegationOption = true
                    } else {
                        try {
                            opt_NegationOption = parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                "-no-negation-option" -> {
                    if (!hasValue) {
                        opt_NegationOption = false
                    } else {
                        try {
                            opt_NegationOption = !parseBoolean(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-option", "-o" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_Option = parseLong(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-propagation-option" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_PropagationOption = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                "-repeatable-option" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_RepeatableOption = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        val expectedArgs = 3

    
        if (arguments.size <= 0) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            arg_FirstArg = parseBoolean(arguments[0])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[0]}\" is not assignable to argument at [0]"
            return
        }
    
        if (arguments.size <= 1) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            arg_SecondArg = parseLong(arguments[1])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[1]}\" is not assignable to argument at [1]"
            return
        }
    
        if (arguments.size < 2) {
            errorMessage = "Too few arguments: required at least ${expectedArgs - 1}, got ${arguments.size}"
            return
        }
        try {
            arg_ThirdArg = parseArrayString(arguments.subList(2, arguments.size))
        } catch (e: Exception) {
            errorMessage = "Values [${arguments.subList(2, arguments.size).joinToString(" ")}] are not assignable to arguments at [2:]"
            return
        }
    
    }
}

// Input class for execute_Sub1
data class Input_Sub1(

    var opt_PropagationOption: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-propagation-option" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_PropagationOption = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_Sub1Sub2
data class Input_Sub1Sub2(

    var opt_PropagationOption: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-propagation-option" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_PropagationOption = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}

// Input class for execute_Sub1Sub2Sub3
data class Input_Sub1Sub2Sub3(

    var opt_PropagationOption: String = "",



    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {

                "-propagation-option" -> {
                    if (!hasValue) {
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                    } else {
                        try {
                            opt_PropagationOption = parseString(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                    }
                }
                

                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        

    
    }
}


// Resolves the subcommand from arguments
internal fun resolveSubcommand(args: Array<String>): Triple<List<String>, List<String>, List<String>> {
    val subcommandSet = mapOf(

        "" to true,

        "sub1" to true,

        "sub1 sub2" to true,

        "sub1 sub2 sub3" to true,

    )

    val subcommandPath = mutableListOf<String>()

    for (arg in args) {
        if (arg == "--") {
            break
        }
        val pathLiteral = (subcommandPath + arg).joinToString(" ")
        if (!subcommandSet.containsKey(pathLiteral)) {
            break
        }
        subcommandPath.add(arg)
    }

    val restArgs = args.drop(subcommandPath.size)
    val options = mutableListOf<String>()
    val arguments = mutableListOf<String>()
    var idx = 0
    while (idx < restArgs.size) {
        val arg = restArgs[idx]
        if (arg == "--") {
            arguments.addAll(restArgs.subList(idx + 1, restArgs.size))
            break
        }
        if (arg.startsWith("-")) {
            options.add(arg)
        } else {
            arguments.add(arg)
        }
        idx++
    }

    return Triple(subcommandPath, options, arguments)
}

// Parses a string value to Boolean
internal fun parseBoolean(strValue: String): Boolean {
    return when(strValue) {
        "true", "1", "t" -> true
        "false", "0", "f" -> false
        else -> throw IllegalArgumentException("Invalid boolean value: $strValue")
    }
}

// Parses a string value to Long
internal fun parseLong(strValue: String): Long {
    return strValue.toLong()
}

// Parses a string value to String
internal fun parseString(strValue: String): String {
    return strValue
}

// Parses a list of string values to a list of Boolean
internal fun parseArrayBoolean(strValues: List<String>): List<Boolean> {
    return strValues.map { parseBoolean(it) }
}

// Parses a list of string values to a list of Long
internal fun parseArrayLong(strValues: List<String>): List<Long> {
    return strValues.map { parseLong(it) }
}

// Parses a list of string values to a list of String
internal fun parseArrayString(strValues: List<String>): List<String> {
    return strValues.map { parseString(it) }
}
fun getVersion(): String {
    return "1.2.3"
}
fun getProgram(): String {
    return "features"
}
// Gets documentation for a subcommand
fun getDoc(subcommands: List<String>): String {
    return when (subcommands.joinToString(" ")) {

        "" -> "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        $ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>]  (default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>  (default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<string>  (default=\"\"):\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n"

        "sub1" -> "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        $ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n"

        "sub1 sub2" -> "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n"

        "sub1 sub2 sub3" -> "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n\n"

        else -> throw IllegalArgumentException("Invalid subcommands: $subcommands")
    }
}
