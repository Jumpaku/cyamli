<?php
// Code generated by cyamli, DO NOT EDIT.

namespace Cyamli\cyamli;

class Cyamli {

    /**
     * Entry point
     * @param CLIHandler $handler
     * @param string[] $args
     */
    public static function Run(CLIHandler $handler, array $args): void {
        [$subcommandPath, $options, $arguments] = self::resolveArgs($args);
        switch (implode(' ', $subcommandPath)) {
            case "":
                $input = new Input();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run($input);
                break;
            case "generate":
                $input = new Input_Generate();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_Generate($input);
                break;
            case "generate dart3":
                $input = new Input_GenerateDart3();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GenerateDart3($input);
                break;
            case "generate docs":
                $input = new Input_GenerateDocs();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GenerateDocs($input);
                break;
            case "generate golang":
                $input = new Input_GenerateGolang();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GenerateGolang($input);
                break;
            case "generate kotlin":
                $input = new Input_GenerateKotlin();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GenerateKotlin($input);
                break;
            case "generate python3":
                $input = new Input_GeneratePython3();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GeneratePython3($input);
                break;
            case "generate typescript":
                $input = new Input_GenerateTypescript();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_GenerateTypescript($input);
                break;
            case "version":
                $input = new Input_Version();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->Run_Version($input);
                break;
        }
    }

    public static function GetVersion(): string {
        return "2.0.0-alpha.1";
    }
    public static function GetProgram(): string {
        return "cyamli";
    }
    public static function GetDoc(array $subcommands): string {
        switch (implode(' ', $subcommands)) {
            case "":
                return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";
        
            case "generate":
                return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";
        
            case "generate dart3":
                return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate docs":
                return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>(default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate golang":
                return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>(default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate kotlin":
                return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>(default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate python3":
                return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "generate typescript":
                return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n        -out-path=<string>(default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>(default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        
            case "version":
                return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>](default=false):\n            shows description of this app.\n\n\n";
        
            default:
                throw new \RuntimeException('invalid subcommands: ' . implode(', ', $subcommands));
        }
    }

    /**
     * @param string[] $args
     * @return array{0: string[], 1: string[], 2: string[]}
     */
    private static function resolveArgs(array $args): array {
        if (count($args) === 0) {
            throw new \RuntimeException('command line arguments are too few');
        }
        $subcommandSet = [
            "" => true,"generate" => true,"generate dart3" => true,"generate docs" => true,"generate golang" => true,"generate kotlin" => true,"generate python3" => true,"generate typescript" => true,"version" => true,
        ];
        $subcommandPath = [];
        $options = [];
        $arguments = [];
        for ($i = 1; $i < count($args); ++$i) {
            if ($args[$i] === '--') break;
            $pathLiteral = implode(' ', array_merge($subcommandPath, [$args[$i]]));
            if (!isset($subcommandSet[$pathLiteral])) break;
            $subcommandPath[] = $args[$i];
        }
        $restArgs = array_slice($args, 1 + count($subcommandPath));
        foreach ($restArgs as $idx => $arg) {
            if ($arg === '--') {
                $arguments = array_merge($arguments, array_slice($restArgs, $idx + 1));
                break;
            }
            if (strpos($arg, '-') === 0) {
                $options[] = $arg;
            } else {
                $arguments[] = $arg;
            }
        }
        return [$subcommandPath, $options, $arguments];
    }

}