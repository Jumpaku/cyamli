<?php
// Code generated by cyamli, DO NOT EDIT.

namespace Cyamli\features;

/**
 * Class Input
 *
 * @property bool $Opt_NegationOption 
 * @property int $Opt_Option 
 * @property string $Opt_PropagationOption 
 * @property array $Opt_RepeatableOption 
 *
 * @property bool $Arg_FirstArg 
 * @property int $Arg_SecondArg 
 * @property array $Arg_ThirdArg 
 *
 * @property string[] $Subcommand
 * @property string[] $Options
 * @property string[] $Arguments
 * @property string $ErrorMessage
 */
class Input {
    /** @var bool */
    public bool $Opt_NegationOption;
    /** @var int */
    public int $Opt_Option;
    /** @var string */
    public string $Opt_PropagationOption;
    /** @var int[] */
    public array $Opt_RepeatableOption;
    /** @var bool */
    public bool $Arg_FirstArg;
    /** @var int */
    public int $Arg_SecondArg;
    /** @var string[] */
    public array $Arg_ThirdArg;
    /** @var string[] */
    public array $Subcommand = [];
    /** @var string[] */
    public array $Options = [];
    /** @var string[] */
    public array $Arguments = [];
    /** @var string */
    public string $ErrorMessage = '';

    /**
     * @param string[] $subcommand
     * @param string[] $options
     * @param string[] $arguments
     */
    public function resolveInput(array $subcommand, array $options, array $arguments): void {
        $this->Opt_NegationOption = false;
        $this->Opt_Option = 123;
        $this->Opt_PropagationOption = "";
        $this->Opt_RepeatableOption = [];
        $this->Subcommand = $subcommand;
        $this->Options = $options;
        $this->Arguments = $arguments;
        $this->ErrorMessage = '';
        foreach ($this->Options as $arg) {
            $cut = strpos($arg, '=');
            $optName = $cut !== false ? substr($arg, 0, $cut) : $arg;
            $lit = $cut !== false ? substr($arg, $cut + 1) : '';
            switch ($optName) {
                case '-negation-option':
                    if ($cut === false) {
                        $lit = 'true';
                    }
                    $v = self::parseValue('bool', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    $this->Opt_NegationOption = $v;
                    break;
                case '-no-negation-option':
                    if ($cut === false) $lit = 'true';
                    $v = self::parseValue('bool', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    $this->Opt_NegationOption = !$v;
                    break;
                
                
                case '-option':
                case '-o':
                    if ($cut === false) {
                        $this->ErrorMessage = "value is not specified to option '$optName'";
                        return;
                    }
                    $v = self::parseValue('int', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    $this->Opt_Option = $v;
                    break;
                
                
                case '-propagation-option':
                    if ($cut === false) {
                        $this->ErrorMessage = "value is not specified to option '$optName'";
                        return;
                    }
                    $v = self::parseValue('string', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    $this->Opt_PropagationOption = $v;
                    break;
                
                
                case '-repeatable-option':
                case '-r':
                    if ($cut === false) {
                        $this->ErrorMessage = "value is not specified to option '$optName'";
                        return;
                    }
                    $v = self::parseValue('int[]', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    $this->Opt_RepeatableOption[] = $v[0];
                    break;
                
                
                default:
                    $this->ErrorMessage = "unknown option '$optName'";
                    return;
            }
        }
        $expectedArgs = 3;
        
        if (count($this->Arguments) <= 0) {
            $this->ErrorMessage = "too few arguments: required $expectedArgs, got " . count($this->Arguments);
            return;
        }
        $v = self::parseValue('bool', ...array_slice($this->Arguments, 0));
        if ($v === null) {
            $this->ErrorMessage = "value '" . $this->Arguments[0] . "' is not assignable to argument at [0]";
            return;
        }
        $this->Arg_FirstArg = $v;
        
        if (count($this->Arguments) <= 1) {
            $this->ErrorMessage = "too few arguments: required $expectedArgs, got " . count($this->Arguments);
            return;
        }
        $v = self::parseValue('int', ...array_slice($this->Arguments, 1));
        if ($v === null) {
            $this->ErrorMessage = "value '" . $this->Arguments[1] . "' is not assignable to argument at [1]";
            return;
        }
        $this->Arg_SecondArg = $v;
        
        if (count($this->Arguments) < 2) {
            $this->ErrorMessage = "too few arguments: required at least " . ($expectedArgs-1) . ", got " . count($this->Arguments);
            return;
        }
        $v = self::parseValue('string[]', ...array_slice($this->Arguments, 2));
        if ($v === null) {
            $this->ErrorMessage = "values [" . implode(' ', array_slice($this->Arguments, 2)) . "] are not assignable to arguments at [2:]";
            return;
        }
        $this->Arg_ThirdArg = $v;
        
    }

    /**
     * @param string $typ
     * @param string ...$strValue
     * @return mixed|null
     */
    private static function parseValue(string $typ, ...$strValue) {
        switch ($typ) {
            case 'bool[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = self::parseValue('bool', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'int[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = self::parseValue('int', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'string[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = self::parseValue('string', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'bool':
                $s = strtolower($strValue[0]);
                if (in_array($s, ['true', '1', 't'], true)) return true;
                if (in_array($s, ['false', '0', 'f'], true)) return false;
                return null;
            case 'int':
                if (is_numeric($strValue[0])) return (int)$strValue[0];
                return null;
            case 'string':
                return $strValue[0];
        }
        return null;
    }
}
