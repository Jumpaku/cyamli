# Code generated by cyamli, DO NOT EDIT.

import sys
import abc
from typing import List, Optional, Any, Dict, Callable, Union, TypeVar, Generic, cast, Tuple

class CLIHandler(abc.ABC):
    @abc.abstractmethod
    def Run(self, input_obj: 'Input') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Generate(self, input_obj: 'Input_Generate') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GenerateDart3(self, input_obj: 'Input_GenerateDart3') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GenerateDocs(self, input_obj: 'Input_GenerateDocs') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GenerateGolang(self, input_obj: 'Input_GenerateGolang') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GenerateKotlin(self, input_obj: 'Input_GenerateKotlin') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GeneratePython3(self, input_obj: 'Input_GeneratePython3') -> None:
        pass
    
    @abc.abstractmethod
    def Run_GenerateTypescript(self, input_obj: 'Input_GenerateTypescript') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Version(self, input_obj: 'Input_Version') -> None:
        pass
    
class Input:
    def __init__(self):
        self.Opt_Help: bool = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_Generate:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GenerateDart3:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GenerateDocs:
    def __init__(self):
        self.Opt_Format: str = None
        
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Format = "text"
        
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-format", "-f"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Format = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GenerateGolang:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_Package: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_Package = "main"
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-package"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Package = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GenerateKotlin:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_Package: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_Package = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-package"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Package = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GeneratePython3:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_GenerateTypescript:
    def __init__(self):
        self.Opt_Help: bool = None
        
        self.Opt_OutPath: str = None
        
        self.Opt_SchemaPath: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        
        self.Opt_OutPath = ""
        
        self.Opt_SchemaPath = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-out-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_OutPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-schema-path"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_SchemaPath = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_Version:
    def __init__(self):
        self.Opt_Help: bool = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Help = False
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-help", "-h"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_Help = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        

def resolve_args(args: List[str]) -> Tuple[List[str], List[str], List[str]]:
    if not args:
        raise ValueError("command line arguments are too few")

    subcommand_set = {
        "": True,"generate": True,"generate dart3": True,"generate docs": True,"generate golang": True,"generate kotlin": True,"generate python3": True,"generate typescript": True,"version": True,
    }

    subcommand_path = []

    for arg in args[1:]:
        if arg == "--":
            break

        path_literal = " ".join(subcommand_path + [arg])
        if path_literal not in subcommand_set:
            break

        subcommand_path.append(arg)

    rest_args = args[1+len(subcommand_path):]

    i = 0
    options = []
    arguments = []
    while i < len(rest_args):
        arg = rest_args[i]
        if arg == "--":
            arguments.extend(rest_args[i+1:])
            break
        elif arg.startswith("-"):
            options.append(arg)
        else:
            arguments.append(arg)
        i += 1

    return subcommand_path, options, arguments

def parse_value(value: str, type_name: str) -> Any:
    """Parse a string value into the specified type."""
    # Handle basic types
    if type_name == "bool":
        if value.lower() in ("true", "t", "yes", "y", "1"):
            return True
        elif value.lower() in ("false", "f", "no", "n", "0"):
            return False
        raise ValueError("cannot parse " + repr(value) + " as bool")

    elif type_name == "int":
        try:
            return int(value)
        except ValueError:
            raise ValueError("cannot parse " + repr(value) + " as int")

    elif type_name == "str":
        return value

    # Handle list types (e.g., List[str])
    elif type_name.startswith("List[") and type_name.endswith("]"):
        inner_type = type_name[5:-1]  # Extract the type inside List[...]
        return [parse_value(value, inner_type)]

    # If we get here, the type is not supported
    raise ValueError("unsupported type: " + type_name)

def run(handler: CLIHandler, args: List[str]) -> None:
    """Entry point for the CLI application."""
    subcommand_path, options, arguments = resolve_args(args)
    subcommand_str = " ".join(subcommand_path)
    if subcommand_str == "":
        input_obj = Input()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run(input_obj)
    
    if subcommand_str == "generate":
        input_obj = Input_Generate()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Generate(input_obj)
    
    if subcommand_str == "generate dart3":
        input_obj = Input_GenerateDart3()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GenerateDart3(input_obj)
    
    if subcommand_str == "generate docs":
        input_obj = Input_GenerateDocs()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GenerateDocs(input_obj)
    
    if subcommand_str == "generate golang":
        input_obj = Input_GenerateGolang()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GenerateGolang(input_obj)
    
    if subcommand_str == "generate kotlin":
        input_obj = Input_GenerateKotlin()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GenerateKotlin(input_obj)
    
    if subcommand_str == "generate python3":
        input_obj = Input_GeneratePython3()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GeneratePython3(input_obj)
    
    if subcommand_str == "generate typescript":
        input_obj = Input_GenerateTypescript()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_GenerateTypescript(input_obj)
    
    if subcommand_str == "version":
        input_obj = Input_Version()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Version(input_obj)
    else:
        return

def get_version() -> str:
    return "2.0.0-alpha.1"

def get_program() -> str:
    return "cyamli"

def get_doc(subcommands: List[str]) -> str:
    """Get documentation for a command."""
    subcommand_str = " ".join(subcommands)
    if subcommand_str == "":
        return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n"
    
    if subcommand_str == "generate":
        return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n"
    
    if subcommand_str == "generate dart3":
        return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "generate docs":
        return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "generate golang":
        return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "generate kotlin":
        return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "generate python3":
        return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "generate typescript":
        return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"
    
    if subcommand_str == "version":
        return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n"
    # If we get here, the subcommand is invalid
    raise ValueError(f"invalid subcommands: {subcommands}")
