# Code generated by cyamli, DO NOT EDIT.

import sys
import abc
from typing import List, Optional, Any, Dict, Callable, Union, TypeVar, Generic, cast, Tuple

class CLIHandler(abc.ABC):
    @abc.abstractmethod
    def Run(self, input_obj: 'Input') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Data(self, input_obj: 'Input_Data') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Schema(self, input_obj: 'Input_Schema') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Tables(self, input_obj: 'Input_Tables') -> None:
        pass
    
class Input:
    def __init__(self):
        self.Opt_Config: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Config = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-config"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Config = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_Data:
    def __init__(self):
        self.Opt_Config: str = None
        
        self.Opt_Where: str = None
        
        self.Arg_Table: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Config = ""
        
        self.Opt_Where = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-config"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Config = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-where"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Where = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 1

        if len(self.arguments) <= 0:
            self.error_message = "too few arguments: required " + str(expected_args) + ", got " + str(len(self.arguments))
            return

        try:
            self.Arg_Table = parse_value(self.arguments[0], "str")
        except ValueError as e:
            self.error_message = "value " + repr(self.arguments[0]) + " is not assignable to argument at [" + str(0) + "]"
            return
        
class Input_Schema:
    def __init__(self):
        self.Opt_Config: str = None
        
        self.Arg_Table: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Config = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-config"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Config = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 1

        if len(self.arguments) <= 0:
            self.error_message = "too few arguments: required " + str(expected_args) + ", got " + str(len(self.arguments))
            return

        try:
            self.Arg_Table = parse_value(self.arguments[0], "str")
        except ValueError as e:
            self.error_message = "value " + repr(self.arguments[0]) + " is not assignable to argument at [" + str(0) + "]"
            return
        
class Input_Tables:
    def __init__(self):
        self.Opt_Config: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_Config = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-config"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_Config = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        

def resolve_args(args: List[str]) -> Tuple[List[str], List[str], List[str]]:
    if not args:
        raise ValueError("command line arguments are too few")

    subcommand_set = {
        "": True,"data": True,"schema": True,"tables": True,
    }

    subcommand_path = []

    for arg in args[1:]:
        if arg == "--":
            break

        path_literal = " ".join(subcommand_path + [arg])
        if path_literal not in subcommand_set:
            break

        subcommand_path.append(arg)

    rest_args = args[1+len(subcommand_path):]

    i = 0
    options = []
    arguments = []
    while i < len(rest_args):
        arg = rest_args[i]
        if arg == "--":
            arguments.extend(rest_args[i+1:])
            break
        elif arg.startswith("-"):
            options.append(arg)
        else:
            arguments.append(arg)
        i += 1

    return subcommand_path, options, arguments

def parse_value(value: str, type_name: str) -> Any:
    """Parse a string value into the specified type."""
    # Handle basic types
    if type_name == "bool":
        if value.lower() in ("true", "t", "yes", "y", "1"):
            return True
        elif value.lower() in ("false", "f", "no", "n", "0"):
            return False
        raise ValueError("cannot parse " + repr(value) + " as bool")

    elif type_name == "int":
        try:
            return int(value)
        except ValueError:
            raise ValueError("cannot parse " + repr(value) + " as int")

    elif type_name == "str":
        return value

    # Handle list types (e.g., List[str])
    elif type_name.startswith("List[") and type_name.endswith("]"):
        inner_type = type_name[5:-1]  # Extract the type inside List[...]
        return [parse_value(value, inner_type)]

    # If we get here, the type is not supported
    raise ValueError("unsupported type: " + type_name)

def run(handler: CLIHandler, args: List[str]) -> None:
    """Entry point for the CLI application."""
    subcommand_path, options, arguments = resolve_args(args)
    subcommand_str = " ".join(subcommand_path)
    if subcommand_str == "":
        input_obj = Input()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run(input_obj)
    
    if subcommand_str == "data":
        input_obj = Input_Data()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Data(input_obj)
    
    if subcommand_str == "schema":
        input_obj = Input_Schema()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Schema(input_obj)
    
    if subcommand_str == "tables":
        input_obj = Input_Tables()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Tables(input_obj)
    else:
        return

def get_version() -> str:
    return ""

def get_program() -> str:
    return "demo"

def get_doc(subcommands: List[str]) -> str:
    """Get documentation for a command."""
    subcommand_str = " ".join(subcommands)
    if subcommand_str == "":
        return "demo \n\n    Syntax:\n        $ demo  [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Subcommands:\n        data:\n            dump data from the specified table from the database.\n\n        schema:\n            fetch schema of the specified table from the database.\n\n        tables:\n            list tables from the database.\n\n\n"
    
    if subcommand_str == "data":
        return "demo data\n\n    Description:\n        dump data from the specified table from the database.\n\n    Syntax:\n        $ demo data [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n        -where=<string>  (default=\"\"):\n            filter data by the condition.\n\n    Arguments:\n        1.  <table:string>\n\n\n"
    
    if subcommand_str == "schema":
        return "demo schema\n\n    Description:\n        fetch schema of the specified table from the database.\n\n    Syntax:\n        $ demo schema [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n    Arguments:\n        1.  <table:string>\n\n\n"
    
    if subcommand_str == "tables":
        return "demo tables\n\n    Description:\n        list tables from the database.\n\n    Syntax:\n        $ demo tables [<option>]...\n\n    Options:\n        -config=<string>  (default=\"\"):\n            path to the config file.\n\n\n"
    # If we get here, the subcommand is invalid
    raise ValueError(f"invalid subcommands: {subcommands}")
