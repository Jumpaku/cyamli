# Code generated by cyamli, DO NOT EDIT.

import sys
import abc
from typing import List, Optional, Any, Dict, Callable, Union, TypeVar, Generic, cast, Tuple

class CLIHandler(abc.ABC):
    @abc.abstractmethod
    def Run(self, input_obj: 'Input') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Sub1(self, input_obj: 'Input_Sub1') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Sub1Sub2(self, input_obj: 'Input_Sub1Sub2') -> None:
        pass
    
    @abc.abstractmethod
    def Run_Sub1Sub2Sub3(self, input_obj: 'Input_Sub1Sub2Sub3') -> None:
        pass
    
class Input:
    def __init__(self):
        self.Opt_NegationOption: bool = None
        
        self.Opt_Option: int = None
        
        self.Opt_PropagationOption: str = None
        
        self.Opt_RepeatableOption: List[int] = None
        
        self.Arg_FirstArg: bool = None
        
        self.Arg_SecondArg: int = None
        
        self.Arg_ThirdArg: List[str] = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_NegationOption = False
        
        self.Opt_Option = 123
        
        self.Opt_PropagationOption = ""
        
        self.Opt_RepeatableOption = []
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-negation-option"]:
                if not cut:
                    lit = "True"

                try:
                    v = parse_value(lit, "bool")
                    self.Opt_NegationOption = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            elif opt_name == "-no-negation-option":
                if not cut:
                    lit = "True"
                try:
                    v = parse_value(lit, "bool")
                    self.Opt_NegationOption = not v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            if opt_name in ["-option", "-o"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "int")
                    self.Opt_Option = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-propagation-option"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_PropagationOption = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            if opt_name in ["-repeatable-option", "-r"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "List[int]")
                    self.Opt_RepeatableOption += v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 3

        if len(self.arguments) <= 0:
            self.error_message = "too few arguments: required " + str(expected_args) + ", got " + str(len(self.arguments))
            return

        try:
            self.Arg_FirstArg = parse_value(self.arguments[0], "bool")
        except ValueError as e:
            self.error_message = "value " + repr(self.arguments[0]) + " is not assignable to argument at [" + str(0) + "]"
            return
        if len(self.arguments) <= 1:
            self.error_message = "too few arguments: required " + str(expected_args) + ", got " + str(len(self.arguments))
            return

        try:
            self.Arg_SecondArg = parse_value(self.arguments[1], "int")
        except ValueError as e:
            self.error_message = "value " + repr(self.arguments[1]) + " is not assignable to argument at [" + str(1) + "]"
            return
        if len(self.arguments) < 2:
            self.error_message = "too few arguments: required at least " + str(expected_args-1) + ", got " + str(len(self.arguments))
            return

        try:
            self.Arg_ThirdArg = sum([parse_value(arg, "List[str]") for arg in self.arguments[2:]], [])
        except ValueError as e:
            self.error_message = "values " + ' '.join(self.arguments[2:]) + " are not assignable to arguments at [" + str(2) + ":]"
            return
        
class Input_Sub1:
    def __init__(self):
        self.Opt_PropagationOption: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_PropagationOption = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-propagation-option"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_PropagationOption = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_Sub1Sub2:
    def __init__(self):
        self.Opt_PropagationOption: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_PropagationOption = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-propagation-option"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_PropagationOption = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        
class Input_Sub1Sub2Sub3:
    def __init__(self):
        self.Opt_PropagationOption: str = None
        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        self.Opt_PropagationOption = ""
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            if opt_name in ["-propagation-option"]:
                if not cut:
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return

                try:
                    v = parse_value(lit, "str")
                    self.Opt_PropagationOption = v
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            
            
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = 0

        

def resolve_args(args: List[str]) -> Tuple[List[str], List[str], List[str]]:
    if not args:
        raise ValueError("command line arguments are too few")

    subcommand_set = {
        "": True,"sub1": True,"sub1 sub2": True,"sub1 sub2 sub3": True,
    }

    subcommand_path = []

    for arg in args[1:]:
        if arg == "--":
            break

        path_literal = " ".join(subcommand_path + [arg])
        if path_literal not in subcommand_set:
            break

        subcommand_path.append(arg)

    rest_args = args[1+len(subcommand_path):]

    i = 0
    options = []
    arguments = []
    while i < len(rest_args):
        arg = rest_args[i]
        if arg == "--":
            arguments.extend(rest_args[i+1:])
            break
        elif arg.startswith("-"):
            options.append(arg)
        else:
            arguments.append(arg)
        i += 1

    return subcommand_path, options, arguments

def parse_value(value: str, type_name: str) -> Any:
    """Parse a string value into the specified type."""
    # Handle basic types
    if type_name == "bool":
        if value.lower() in ("true", "t", "yes", "y", "1"):
            return True
        elif value.lower() in ("false", "f", "no", "n", "0"):
            return False
        raise ValueError("cannot parse " + repr(value) + " as bool")

    elif type_name == "int":
        try:
            return int(value)
        except ValueError:
            raise ValueError("cannot parse " + repr(value) + " as int")

    elif type_name == "str":
        return value

    # Handle list types (e.g., List[str])
    elif type_name.startswith("List[") and type_name.endswith("]"):
        inner_type = type_name[5:-1]  # Extract the type inside List[...]
        return [parse_value(value, inner_type)]

    # If we get here, the type is not supported
    raise ValueError("unsupported type: " + type_name)

def run(handler: CLIHandler, args: List[str]) -> None:
    """Entry point for the CLI application."""
    subcommand_path, options, arguments = resolve_args(args)
    subcommand_str = " ".join(subcommand_path)
    if subcommand_str == "":
        input_obj = Input()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run(input_obj)
    
    if subcommand_str == "sub1":
        input_obj = Input_Sub1()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Sub1(input_obj)
    
    if subcommand_str == "sub1 sub2":
        input_obj = Input_Sub1Sub2()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Sub1Sub2(input_obj)
    
    if subcommand_str == "sub1 sub2 sub3":
        input_obj = Input_Sub1Sub2Sub3()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.Run_Sub1Sub2Sub3(input_obj)
    else:
        return

def get_version() -> str:
    return "1.2.3"

def get_program() -> str:
    return "features"

def get_doc(subcommands: List[str]) -> str:
    """Get documentation for a command."""
    subcommand_str = " ".join(subcommands)
    if subcommand_str == "":
        return "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        $ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>](default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>(default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<integer> ... , -r=<integer> ... :\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n"
    
    if subcommand_str == "sub1":
        return "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        $ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n"
    
    if subcommand_str == "sub1 sub2":
        return "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n"
    
    if subcommand_str == "sub1 sub2 sub3":
        return "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>(default=\"\"):\n            this option is available with the descendant commands.\n\n\n"
    # If we get here, the subcommand is invalid
    raise ValueError(f"invalid subcommands: {subcommands}")
