// Code generated by cyamli, DO NOT EDIT.
/**
 * Entry point for the CLI application.
 * @param {(CLIHandler)} handler - The CLIHandler instance to handle commands.
 * @param {(string[])} args - The command-line arguments.
 * @returns {(Promise<void>)} A promise that resolves when the application finishes execution.
 */
export async function run(handler, args) {
    const [subcommandPath, options, positionalArguments] = resolveSubcommand(args);
    switch (subcommandPath.join(' ')) {
        case "":
            {
                const input = new Input();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run(input);
            }
        case "generate":
            {
                const input = new Input_Generate();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Generate(input);
            }
        case "generate dart3":
            {
                const input = new Input_GenerateDart3();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GenerateDart3(input);
            }
        case "generate docs":
            {
                const input = new Input_GenerateDocs();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GenerateDocs(input);
            }
        case "generate golang":
            {
                const input = new Input_GenerateGolang();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GenerateGolang(input);
            }
        case "generate kotlin":
            {
                const input = new Input_GenerateKotlin();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GenerateKotlin(input);
            }
        case "generate python3":
            {
                const input = new Input_GeneratePython3();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GeneratePython3(input);
            }
        case "generate typescript":
            {
                const input = new Input_GenerateTypescript();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_GenerateTypescript(input);
            }
        case "version":
            {
                const input = new Input_Version();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Version(input);
            }
        default:
            throw new Error();
    }
}
/**
 * Input class for run.
 * @type { (Input) }
 */
export class Input {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_Generate.
 * @type { (Input_Generate) }
 */
export class Input_Generate {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GenerateDart3.
 * @type { (Input_GenerateDart3) }
 */
export class Input_GenerateDart3 {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GenerateDocs.
 * @type { (Input_GenerateDocs) }
 */
export class Input_GenerateDocs {
    /**
     * -format option.
     * @type { (string) }
     */
    opt_Format = "text";
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-format':
                case '-f':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Format = v;
                    }
                    break;
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GenerateGolang.
 * @type { (Input_GenerateGolang) }
 */
export class Input_GenerateGolang {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -package option.
     * @type { (string) }
     */
    opt_Package = "main";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-package':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Package = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GenerateKotlin.
 * @type { (Input_GenerateKotlin) }
 */
export class Input_GenerateKotlin {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -package option.
     * @type { (string) }
     */
    opt_Package = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-package':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Package = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GeneratePython3.
 * @type { (Input_GeneratePython3) }
 */
export class Input_GeneratePython3 {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_GenerateTypescript.
 * @type { (Input_GenerateTypescript) }
 */
export class Input_GenerateTypescript {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * -out-path option.
     * @type { (string) }
     */
    opt_OutPath = "";
    /**
     * -schema-path option.
     * @type { (string) }
     */
    opt_SchemaPath = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                case '-out-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_OutPath = v;
                    }
                    break;
                case '-schema-path':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_SchemaPath = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_Version.
 * @type { (Input_Version) }
 */
export class Input_Version {
    /**
     * -help option.
     * @type { (boolean) }
     */
    opt_Help = false;
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-help':
                case '-h':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Help = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Resolves the subcommand from the arguments.
 * @param {(string[])} args - The command-line arguments.
 * @returns {([string[], string[]])} A tuple containing the subcommand path and remaining arguments.
 */
function resolveSubcommand(args) {
    const subcommandSet = {
        "": true,
        "generate": true,
        "generate dart3": true,
        "generate docs": true,
        "generate golang": true,
        "generate kotlin": true,
        "generate python3": true,
        "generate typescript": true,
        "version": true,
    };
    const subcommandPath = [];
    for (const arg of args) {
        if (arg === '--') {
            break;
        }
        const pathLiteral = [...subcommandPath, arg].join(' ');
        if (!subcommandSet[pathLiteral]) {
            break;
        }
        subcommandPath.push(arg);
    }
    const restArgs = args.slice(subcommandPath.length);
    const options = [];
    const positionalArguments = [];
    for (let idx = 0; idx < restArgs.length; idx++) {
        const arg = restArgs[idx];
        if (arg === '--') {
            positionalArguments.push(...restArgs.slice(idx + 1));
            break;
        }
        if (arg.startsWith('-')) {
            options.push(arg);
        }
        else {
            positionalArguments.push(arg);
        }
    }
    return [subcommandPath, options, positionalArguments];
}
/**
 * Parses a string value to the specified type.
 * @param {(string)} strValue - The string value to parse.
 * @param {(string)} typeName - The target type name.
 * @returns {(any)} The parsed value.
 */
function parseValue(strValue, typeName) {
    switch (typeName) {
        case 'boolean[]':
            return [parseValue(strValue, 'boolean')];
        case 'number[]':
            return [parseValue(strValue, 'number')];
        case 'string[]':
            return [parseValue(strValue, 'string')];
        case 'boolean':
            if (['true', 't', '1'].includes(strValue.toLowerCase()))
                return true;
            if (['false', 'f', '0'].includes(strValue.toLowerCase()))
                return false;
            throw new Error(`Failed to parse "${strValue}" as boolean`);
        case 'number':
            const num = parseInt(strValue, 10);
            if (isNaN(num))
                throw new Error(`Failed to parse "${strValue}" as number`);
            return num;
        case 'string':
            return strValue;
        default:
            throw new Error(`Unsupported type: ${typeName}`);
    }
}
/**
 * Returns the version of the program.
 * @returns {(string)} The program version.
 */
export function getVersion() {
    return '2.0.0-alpha.1';
}
/**
 * Returns the program name.
 * @returns {(string)} The program name.
 */
export function getProgram() {
    return 'cyamli';
}
/**
 * Gets documentation for a subcommand.
 * @param {(string[])} subcommands - The subcommand path.
 * @returns {(string)} The documentation text for the subcommand.
 */
export function getDoc(subcommands) {
    switch (subcommands.join(' ')) {
        case "":
            return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";
        case "generate":
            return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";
        case "generate dart3":
            return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "generate docs":
            return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "generate golang":
            return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "generate kotlin":
            return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "generate python3":
            return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "generate typescript":
            return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";
        case "version":
            return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n";
        default:
            throw new Error(`Invalid subcommands: ${subcommands}`);
    }
}
