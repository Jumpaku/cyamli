// Code generated by cyamli, DO NOT EDIT.

/**
 * @typedef {({
 * run: function(Input): Promise<void>,
 * run_Generate: function(Input_Generate): Promise<void>,
 * run_GenerateDart3: function(Input_GenerateDart3): Promise<void>,
 * run_GenerateDocs: function(Input_GenerateDocs): Promise<void>,
 * run_GenerateGolang: function(Input_GenerateGolang): Promise<void>,
 * run_GenerateKotlin: function(Input_GenerateKotlin): Promise<void>,
 * run_GeneratePython3: function(Input_GeneratePython3): Promise<void>,
 * run_GenerateTypescript: function(Input_GenerateTypescript): Promise<void>,
 * run_Version: function(Input_Version): Promise<void>,
 * })} CLIHandler
 */
/**
 * Type declaration for CLIHandler
 * @type {(CLIHandler)}
 */
export interface CLIHandler {

  /**
   * Handles the run command.
   * @param { (Input) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run(input: Input): Promise<void>;

  /**
   * Handles the run_Generate command.
   * @param { (Input_Generate) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_Generate(input: Input_Generate): Promise<void>;

  /**
   * Handles the run_GenerateDart3 command.
   * @param { (Input_GenerateDart3) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GenerateDart3(input: Input_GenerateDart3): Promise<void>;

  /**
   * Handles the run_GenerateDocs command.
   * @param { (Input_GenerateDocs) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GenerateDocs(input: Input_GenerateDocs): Promise<void>;

  /**
   * Handles the run_GenerateGolang command.
   * @param { (Input_GenerateGolang) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GenerateGolang(input: Input_GenerateGolang): Promise<void>;

  /**
   * Handles the run_GenerateKotlin command.
   * @param { (Input_GenerateKotlin) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GenerateKotlin(input: Input_GenerateKotlin): Promise<void>;

  /**
   * Handles the run_GeneratePython3 command.
   * @param { (Input_GeneratePython3) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GeneratePython3(input: Input_GeneratePython3): Promise<void>;

  /**
   * Handles the run_GenerateTypescript command.
   * @param { (Input_GenerateTypescript) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_GenerateTypescript(input: Input_GenerateTypescript): Promise<void>;

  /**
   * Handles the run_Version command.
   * @param { (Input_Version) } input - The input parameters for the command.
   * @returns {(Promise<void>)} A promise that resolves when the command is executed.
   */
  run_Version(input: Input_Version): Promise<void>;

}

/**
 * Entry point for the CLI application.
 * @param {(CLIHandler)} handler - The CLIHandler instance to handle commands.
 * @param {(string[])} args - The command-line arguments.
 * @returns {(Promise<void>)} A promise that resolves when the application finishes execution.
 */
export async function run(handler: CLIHandler, args: string[]): Promise<void> {
  const [subcommandPath, options, positionalArguments] = resolveSubcommand(args);

  switch (subcommandPath.join(' ')) {

  case "":
    {
      const input = new Input();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run(input);
    }

  case "generate":
    {
      const input = new Input_Generate();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_Generate(input);
    }

  case "generate dart3":
    {
      const input = new Input_GenerateDart3();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GenerateDart3(input);
    }

  case "generate docs":
    {
      const input = new Input_GenerateDocs();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GenerateDocs(input);
    }

  case "generate golang":
    {
      const input = new Input_GenerateGolang();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GenerateGolang(input);
    }

  case "generate kotlin":
    {
      const input = new Input_GenerateKotlin();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GenerateKotlin(input);
    }

  case "generate python3":
    {
      const input = new Input_GeneratePython3();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GeneratePython3(input);
    }

  case "generate typescript":
    {
      const input = new Input_GenerateTypescript();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_GenerateTypescript(input);
    }

  case "version":
    {
      const input = new Input_Version();
      input.resolveInput(subcommandPath, options, positionalArguments);
      return handler.run_Version(input);
    }

  default:
    throw new Error();
  }
}


/**
 * Input class for run.
 * @type { (Input) }
 */
export class Input {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_Generate.
 * @type { (Input_Generate) }
 */
export class Input_Generate {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GenerateDart3.
 * @type { (Input_GenerateDart3) }
 */
export class Input_GenerateDart3 {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GenerateDocs.
 * @type { (Input_GenerateDocs) }
 */
export class Input_GenerateDocs {

  /**
   * -format option.
   * @type { (string) }
   */
  public opt_Format: string = "text";

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-format':
      case '-f':
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Format = v;
  
        }
        break;
  

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GenerateGolang.
 * @type { (Input_GenerateGolang) }
 */
export class Input_GenerateGolang {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -package option.
   * @type { (string) }
   */
  public opt_Package: string = "main";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-package':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Package = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GenerateKotlin.
 * @type { (Input_GenerateKotlin) }
 */
export class Input_GenerateKotlin {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -package option.
   * @type { (string) }
   */
  public opt_Package: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-package':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Package = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GeneratePython3.
 * @type { (Input_GeneratePython3) }
 */
export class Input_GeneratePython3 {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_GenerateTypescript.
 * @type { (Input_GenerateTypescript) }
 */
export class Input_GenerateTypescript {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;

  /**
   * -out-path option.
   * @type { (string) }
   */
  public opt_OutPath: string = "";

  /**
   * -schema-path option.
   * @type { (string) }
   */
  public opt_SchemaPath: string = "";



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      case '-out-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_OutPath = v;
  
        }
        break;
  

      case '-schema-path':
  
        {
          if (cut < 0) {
  
            this.errorMessage = `Value is not specified to option "${optName}"`;
            return;
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'string');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_SchemaPath = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}

/**
 * Input class for run_Version.
 * @type { (Input_Version) }
 */
export class Input_Version {

  /**
   * -help option.
   * @type { (boolean) }
   */
  public opt_Help: boolean = false;



  /**
   * Subcommand path.
   * @type {(string[])}
   */
  public subcommand: string[] = [];

  /**
   * Options provided in the command.
   * @type {(string[])}
   */
  public options: string[] = [];

  /**
   * Positional arguments provided in the command.
   * @type {(string[])}
   */
  public arguments: string[] = [];

  /**
   * Error message if input resolution fails.
   * @type {(string | null)}
   */
  public errorMessage: string | null = null;

  /**
   * Resolves input from command-line arguments.
   * @param {(string[])} subcommand - The subcommand in command-line arguments.
   * @param {(string[])} options - The options in command-line arguments.
   * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
   */
  resolveInput(subcommand: string[], options: string[], positionalArguments: string[]): void {
    this.subcommand = subcommand;
    this.options = options;
    this.arguments = positionalArguments;

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {

      case '-help':
      case '-h':
        {
          if (cut < 0) {
  
            lit = 'true';
  
          }
          let v: any;
          try {
            v = parseValue(lit!, 'boolean');
          } catch (e) {
            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
            return;
          }
  
          this.opt_Help = v;
  
        }
        break;
  

      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = 0;


  }
}


/**
 * Resolves the subcommand from the arguments.
 * @param {(string[])} args - The command-line arguments.
 * @returns {([string[], string[]])} A tuple containing the subcommand path and remaining arguments.
 */
function resolveSubcommand(args: string[]): [string[], string[], string[]] {
  const subcommandSet: {[key: string]: boolean} = {
    "": true,
    "generate": true,
    "generate dart3": true,
    "generate docs": true,
    "generate golang": true,
    "generate kotlin": true,
    "generate python3": true,
    "generate typescript": true,
    "version": true,

  };

  const subcommandPath: string[] = [];
  for (const arg of args) {
    if (arg === '--') {
      break;
    }
    const pathLiteral = [...subcommandPath, arg].join(' ');
    if (!subcommandSet[pathLiteral]) {
      break;
    }
    subcommandPath.push(arg);
  }

  const restArgs = args.slice(subcommandPath.length);
  const options: string[] = [];
  const positionalArguments: string[] = [];
  for (let idx = 0; idx < restArgs.length; idx++) {
    const arg = restArgs[idx];
    if (arg === '--') {
      positionalArguments.push(...restArgs.slice(idx + 1));
      break;
    }
    if (arg.startsWith('-')) {
      options.push(arg);
    } else {
      positionalArguments.push(arg);
    }
  }

  return [subcommandPath, options, positionalArguments];
}

/**
 * Parses a string value to the specified type.
 * @param {(string)} strValue - The string value to parse.
 * @param {(string)} typeName - The target type name.
 * @returns {(any)} The parsed value.
 */
function parseValue(strValue: string, typeName: string): any {
  switch (typeName) {
    case 'boolean[]':
      return [parseValue(strValue, 'boolean')];
    case 'number[]':
      return [parseValue(strValue, 'number')];
    case 'string[]':
      return [parseValue(strValue, 'string')];
    case 'boolean':
      if (['true', 't', '1'].includes(strValue.toLowerCase())) return true;
      if (['false', 'f', '0'].includes(strValue.toLowerCase())) return false;
      throw new Error(`Failed to parse "${strValue}" as boolean`);
    case 'number':
      const num = parseInt(strValue, 10);
      if (isNaN(num)) throw new Error(`Failed to parse "${strValue}" as number`);
      return num;
    case 'string':
      return strValue;
    default:
      throw new Error(`Unsupported type: ${typeName}`);
  }
}

/**
 * Returns the version of the program.
 * @returns {(string)} The program version.
 */
export function getVersion(): string {
  return '2.0.0-alpha.1';
}

/**
 * Returns the program name.
 * @returns {(string)} The program name.
 */
export function getProgram(): string {
  return 'cyamli';
}

/**
 * Gets documentation for a subcommand.
 * @param {(string[])} subcommands - The subcommand path.
 * @returns {(string)} The documentation text for the subcommand.
 */
export function getDoc(subcommands: string[]): string {
  switch (subcommands.join(' ')) {

    case "":
      return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n";

    case "generate":
      return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n";

    case "generate dart3":
      return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "generate docs":
      return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "generate golang":
      return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "generate kotlin":
      return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "generate python3":
      return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "generate typescript":
      return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n";

    case "version":
      return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n";

    default:
      throw new Error(`Invalid subcommands: ${subcommands}`);
  }
}
