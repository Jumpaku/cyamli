// Code generated by cyamli, DO NOT EDIT.
/**
 * Entry point for the CLI application.
 * @param {(CLIHandler)} handler - The CLIHandler instance to handle commands.
 * @param {(string[])} args - The command-line arguments.
 * @returns {(Promise<void>)} A promise that resolves when the application finishes execution.
 */
export async function run(handler, args) {
    const [subcommandPath, options, positionalArguments] = resolveSubcommand(args);
    switch (subcommandPath.join(' ')) {
        case "":
            {
                const input = new Input();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run(input);
            }
        case "data":
            {
                const input = new Input_Data();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Data(input);
            }
        case "schema":
            {
                const input = new Input_Schema();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Schema(input);
            }
        case "tables":
            {
                const input = new Input_Tables();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Tables(input);
            }
        default:
            throw new Error();
    }
}
/**
 * Input class for run.
 * @type { (Input) }
 */
export class Input {
    /**
     * -config option.
     * @type { (string) }
     */
    opt_Config = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-config':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Config = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_Data.
 * @type { (Input_Data) }
 */
export class Input_Data {
    /**
     * -config option.
     * @type { (string) }
     */
    opt_Config = "";
    /**
     * -where option.
     * @type { (string) }
     */
    opt_Where = "";
    /**
     * Argument of type string.
     * @type { (string) }
     */
    arg_Table = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-config':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Config = v;
                    }
                    break;
                case '-where':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Where = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 1;
        if (this.arguments.length <= 0) {
            this.errorMessage = `Too few arguments: required ${expectedArgs}, got ${this.arguments.length}`;
            return;
        }
        try {
            this.arg_Table = parseValue(this.arguments[0], 'string');
        }
        catch (e) {
            this.errorMessage = `Value "${this.arguments[0]}" is not assignable to argument at [0]`;
            return;
        }
    }
}
/**
 * Input class for run_Schema.
 * @type { (Input_Schema) }
 */
export class Input_Schema {
    /**
     * -config option.
     * @type { (string) }
     */
    opt_Config = "";
    /**
     * Argument of type string.
     * @type { (string) }
     */
    arg_Table = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-config':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Config = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 1;
        if (this.arguments.length <= 0) {
            this.errorMessage = `Too few arguments: required ${expectedArgs}, got ${this.arguments.length}`;
            return;
        }
        try {
            this.arg_Table = parseValue(this.arguments[0], 'string');
        }
        catch (e) {
            this.errorMessage = `Value "${this.arguments[0]}" is not assignable to argument at [0]`;
            return;
        }
    }
}
/**
 * Input class for run_Tables.
 * @type { (Input_Tables) }
 */
export class Input_Tables {
    /**
     * -config option.
     * @type { (string) }
     */
    opt_Config = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-config':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Config = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Resolves the subcommand from the arguments.
 * @param {(string[])} args - The command-line arguments.
 * @returns {([string[], string[]])} A tuple containing the subcommand path and remaining arguments.
 */
function resolveSubcommand(args) {
    const subcommandSet = {
        "": true,
        "data": true,
        "schema": true,
        "tables": true,
    };
    const subcommandPath = [];
    for (const arg of args) {
        if (arg === '--') {
            break;
        }
        const pathLiteral = [...subcommandPath, arg].join(' ');
        if (!subcommandSet[pathLiteral]) {
            break;
        }
        subcommandPath.push(arg);
    }
    const restArgs = args.slice(subcommandPath.length);
    const options = [];
    const positionalArguments = [];
    for (let idx = 0; idx < restArgs.length; idx++) {
        const arg = restArgs[idx];
        if (arg === '--') {
            positionalArguments.push(...restArgs.slice(idx + 1));
            break;
        }
        if (arg.startsWith('-')) {
            options.push(arg);
        }
        else {
            positionalArguments.push(arg);
        }
    }
    return [subcommandPath, options, positionalArguments];
}
/**
 * Parses a string value to the specified type.
 * @param {(string)} strValue - The string value to parse.
 * @param {(string)} typeName - The target type name.
 * @returns {(any)} The parsed value.
 */
function parseValue(strValue, typeName) {
    switch (typeName) {
        case 'boolean[]':
            return [parseValue(strValue, 'boolean')];
        case 'number[]':
            return [parseValue(strValue, 'number')];
        case 'string[]':
            return [parseValue(strValue, 'string')];
        case 'boolean':
            if (['true', 't', '1'].includes(strValue.toLowerCase()))
                return true;
            if (['false', 'f', '0'].includes(strValue.toLowerCase()))
                return false;
            throw new Error(`Failed to parse "${strValue}" as boolean`);
        case 'number':
            const num = parseInt(strValue, 10);
            if (isNaN(num))
                throw new Error(`Failed to parse "${strValue}" as number`);
            return num;
        case 'string':
            return strValue;
        default:
            throw new Error(`Unsupported type: ${typeName}`);
    }
}
/**
 * Returns the version of the program.
 * @returns {(string)} The program version.
 */
export function getVersion() {
    return '';
}
/**
 * Returns the program name.
 * @returns {(string)} The program name.
 */
export function getProgram() {
    return 'demo';
}
/**
 * Gets documentation for a subcommand.
 * @param {(string[])} subcommands - The subcommand path.
 * @returns {(string)} The documentation text for the subcommand.
 */
export function getDoc(subcommands) {
    switch (subcommands.join(' ')) {
        case "":
            return "demo \n\n    Syntax:\n        $ demo  [<option>]...\n\n    Options:\n        -config=<string>(default=\"\"):\n            path to the config file.\n\n    Subcommands:\n        data:\n            dump data from the specified table from the database.\n\n        schema:\n            fetch schema of the specified table from the database.\n\n        tables:\n            list tables from the database.\n\n\n";
        case "data":
            return "demo data\n\n    Description:\n        dump data from the specified table from the database.\n\n    Syntax:\n        $ demo data [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>(default=\"\"):\n            path to the config file.\n\n        -where=<string>(default=\"\"):\n            filter data by the condition.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
        case "schema":
            return "demo schema\n\n    Description:\n        fetch schema of the specified table from the database.\n\n    Syntax:\n        $ demo schema [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -config=<string>(default=\"\"):\n            path to the config file.\n\n    Arguments:\n        1.  <table:string>\n\n\n";
        case "tables":
            return "demo tables\n\n    Description:\n        list tables from the database.\n\n    Syntax:\n        $ demo tables [<option>]...\n\n    Options:\n        -config=<string>(default=\"\"):\n            path to the config file.\n\n\n";
        default:
            throw new Error(`Invalid subcommands: ${subcommands}`);
    }
}
