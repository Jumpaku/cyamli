// Code generated by cyamli, DO NOT EDIT.
/**
 * Entry point for the CLI application.
 * @param {(CLIHandler)} handler - The CLIHandler instance to handle commands.
 * @param {(string[])} args - The command-line arguments.
 * @returns {(Promise<void>)} A promise that resolves when the application finishes execution.
 */
export async function run(handler, args) {
    const [subcommandPath, options, positionalArguments] = resolveSubcommand(args);
    switch (subcommandPath.join(' ')) {
        case "":
            {
                const input = new Input();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run(input);
            }
        case "sub1":
            {
                const input = new Input_Sub1();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Sub1(input);
            }
        case "sub1 sub2":
            {
                const input = new Input_Sub1Sub2();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Sub1Sub2(input);
            }
        case "sub1 sub2 sub3":
            {
                const input = new Input_Sub1Sub2Sub3();
                input.resolveInput(subcommandPath, options, positionalArguments);
                return handler.run_Sub1Sub2Sub3(input);
            }
        default:
            throw new Error();
    }
}
/**
 * Input class for run.
 * @type { (Input) }
 */
export class Input {
    /**
     * -negation-option option.
     * @type { (boolean) }
     */
    opt_NegationOption = false;
    /**
     * -option option.
     * @type { (number) }
     */
    opt_Option = 123;
    /**
     * -propagation-option option.
     * @type { (string) }
     */
    opt_PropagationOption = "";
    /**
     * -repeatable-option option.
     * @type { (string) }
     */
    opt_RepeatableOption = "";
    /**
     * Argument of type boolean.
     * @type { (boolean) }
     */
    arg_FirstArg = false;
    /**
     * Argument of type number.
     * @type { (number) }
     */
    arg_SecondArg = 0;
    /**
     * Argument of type string[].
     * @type { (string[]) }
     */
    arg_ThirdArg = [];
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-negation-option':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_NegationOption = v;
                    }
                    break;
                case '-no-negation-option':
                    {
                        if (cut < 0) {
                            lit = 'true';
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'boolean');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_NegationOption = !v;
                    }
                    break;
                case '-option':
                case '-o':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'number');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_Option = v;
                    }
                    break;
                case '-propagation-option':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_PropagationOption = v;
                    }
                    break;
                case '-repeatable-option':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_RepeatableOption = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 3;
        if (this.arguments.length <= 0) {
            this.errorMessage = `Too few arguments: required ${expectedArgs}, got ${this.arguments.length}`;
            return;
        }
        try {
            this.arg_FirstArg = parseValue(this.arguments[0], 'boolean');
        }
        catch (e) {
            this.errorMessage = `Value "${this.arguments[0]}" is not assignable to argument at [0]`;
            return;
        }
        if (this.arguments.length <= 1) {
            this.errorMessage = `Too few arguments: required ${expectedArgs}, got ${this.arguments.length}`;
            return;
        }
        try {
            this.arg_SecondArg = parseValue(this.arguments[1], 'number');
        }
        catch (e) {
            this.errorMessage = `Value "${this.arguments[1]}" is not assignable to argument at [1]`;
            return;
        }
        if (this.arguments.length < 2) {
            this.errorMessage = `Too few arguments: required at least ${expectedArgs - 1}, got ${this.arguments.length}`;
            return;
        }
        try {
            this.arg_ThirdArg = this.arguments.slice(2).map(s => parseValue(s, 'string[]')).flat();
        }
        catch (e) {
            this.errorMessage = `Values [${this.arguments.slice(2).join(' ')}] are not assignable to arguments at [2:]`;
            return;
        }
    }
}
/**
 * Input class for run_Sub1.
 * @type { (Input_Sub1) }
 */
export class Input_Sub1 {
    /**
     * -propagation-option option.
     * @type { (string) }
     */
    opt_PropagationOption = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-propagation-option':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_PropagationOption = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_Sub1Sub2.
 * @type { (Input_Sub1Sub2) }
 */
export class Input_Sub1Sub2 {
    /**
     * -propagation-option option.
     * @type { (string) }
     */
    opt_PropagationOption = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-propagation-option':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_PropagationOption = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Input class for run_Sub1Sub2Sub3.
 * @type { (Input_Sub1Sub2Sub3) }
 */
export class Input_Sub1Sub2Sub3 {
    /**
     * -propagation-option option.
     * @type { (string) }
     */
    opt_PropagationOption = "";
    /**
     * Subcommand path.
     * @type {(string[])}
     */
    subcommand = [];
    /**
     * Options provided in the command.
     * @type {(string[])}
     */
    options = [];
    /**
     * Positional arguments provided in the command.
     * @type {(string[])}
     */
    arguments = [];
    /**
     * Error message if input resolution fails.
     * @type {(string | null)}
     */
    errorMessage = null;
    /**
     * Resolves input from command-line arguments.
     * @param {(string[])} subcommand - The subcommand in command-line arguments.
     * @param {(string[])} options - The options in command-line arguments.
     * @param {(string[])} positionalArguments - The positionalArguments in command-line arguments.
     */
    resolveInput(subcommand, options, positionalArguments) {
        this.subcommand = subcommand;
        this.options = options;
        this.arguments = positionalArguments;
        for (const arg of this.options) {
            const cut = arg.indexOf('=');
            let optName;
            let lit;
            if (cut >= 0) {
                optName = arg.substring(0, cut);
                lit = arg.substring(cut + 1);
            }
            else {
                optName = arg;
            }
            switch (optName) {
                case '-propagation-option':
                    {
                        if (cut < 0) {
                            this.errorMessage = `Value is not specified to option "${optName}"`;
                            return;
                        }
                        let v;
                        try {
                            v = parseValue(lit, 'string');
                        }
                        catch (e) {
                            this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
                            return;
                        }
                        this.opt_PropagationOption = v;
                    }
                    break;
                default:
                    this.errorMessage = `Unknown option "${optName}"`;
                    return;
            }
        }
        const expectedArgs = 0;
    }
}
/**
 * Resolves the subcommand from the arguments.
 * @param {(string[])} args - The command-line arguments.
 * @returns {([string[], string[]])} A tuple containing the subcommand path and remaining arguments.
 */
function resolveSubcommand(args) {
    const subcommandSet = {
        "": true,
        "sub1": true,
        "sub1 sub2": true,
        "sub1 sub2 sub3": true,
    };
    const subcommandPath = [];
    for (const arg of args) {
        if (arg === '--') {
            break;
        }
        const pathLiteral = [...subcommandPath, arg].join(' ');
        if (!subcommandSet[pathLiteral]) {
            break;
        }
        subcommandPath.push(arg);
    }
    const restArgs = args.slice(subcommandPath.length);
    const options = [];
    const positionalArguments = [];
    for (let idx = 0; idx < restArgs.length; idx++) {
        const arg = restArgs[idx];
        if (arg === '--') {
            positionalArguments.push(...restArgs.slice(idx + 1));
            break;
        }
        if (arg.startsWith('-')) {
            options.push(arg);
        }
        else {
            positionalArguments.push(arg);
        }
    }
    return [subcommandPath, options, positionalArguments];
}
/**
 * Parses a string value to the specified type.
 * @param {(string)} strValue - The string value to parse.
 * @param {(string)} typeName - The target type name.
 * @returns {(any)} The parsed value.
 */
function parseValue(strValue, typeName) {
    switch (typeName) {
        case 'boolean[]':
            return [parseValue(strValue, 'boolean')];
        case 'number[]':
            return [parseValue(strValue, 'number')];
        case 'string[]':
            return [parseValue(strValue, 'string')];
        case 'boolean':
            if (['true', 't', '1'].includes(strValue.toLowerCase()))
                return true;
            if (['false', 'f', '0'].includes(strValue.toLowerCase()))
                return false;
            throw new Error(`Failed to parse "${strValue}" as boolean`);
        case 'number':
            const num = parseInt(strValue, 10);
            if (isNaN(num))
                throw new Error(`Failed to parse "${strValue}" as number`);
            return num;
        case 'string':
            return strValue;
        default:
            throw new Error(`Unsupported type: ${typeName}`);
    }
}
/**
 * Returns the version of the program.
 * @returns {(string)} The program version.
 */
export function getVersion() {
    return '1.2.3';
}
/**
 * Returns the program name.
 * @returns {(string)} The program name.
 */
export function getProgram() {
    return 'features';
}
/**
 * Gets documentation for a subcommand.
 * @param {(string[])} subcommands - The subcommand path.
 * @returns {(string)} The documentation text for the subcommand.
 */
export function getDoc(subcommands) {
    switch (subcommands.join(' ')) {
        case "":
            return "features \n\n    Description:\n        This is root command, which is a command with name and version.\n\n    Syntax:\n        $ features  [<option>|<argument>]... [-- [<argument>]...]\n\n    Options:\n        -negation-option[=<boolean>]  (default=false),\n        -no-negation-option[=<boolean>]:\n            this option's negated version `-no-negation-option` can be available.\n\n        -option=<integer>, -o=<integer>  (default=123):\n            option can have:\n              a description,\n              a type of string, integer, or boolean,\n              a short name,\n              and a default value.\n\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n        -repeatable-option=<string>  (default=\"\"):\n            this option can be repeated multiple times.\n\n    Arguments:\n        1.  <first_arg:boolean>\n            first argument with type boolean\n\n        2.  <second_arg:integer>\n            second argument with type boolean\n\n        3. [<third_arg:string>]...\n            third argument, which can take multiple values.\n\n    Subcommands:\n        sub1:\n            this is a child command.\n\n\n";
        case "sub1":
            return "features sub1\n\n    Description:\n        this is a child command.\n\n    Syntax:\n        $ features sub1 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub2:\n            this is a grandchild command.\n\n\n";
        case "sub1 sub2":
            return "features sub1 sub2\n\n    Description:\n        this is a grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n    Subcommands:\n        sub3:\n            this is a great-grandchild command.\n\n\n";
        case "sub1 sub2 sub3":
            return "features sub1 sub2 sub3\n\n    Description:\n        this is a great-grandchild command.\n\n    Syntax:\n        $ features sub1 sub2 sub3 [<option>]...\n\n    Options:\n        -propagation-option=<string>  (default=\"\"):\n            this option is available with the descendant commands.\n\n\n";
        default:
            throw new Error(`Invalid subcommands: ${subcommands}`);
    }
}
