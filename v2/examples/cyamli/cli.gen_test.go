// Code generated by cyamli, DO NOT EDIT.
package cyamli_test

import (
	"fmt"
	"strconv"
	"strings"
)

type CLIHandler interface {
	Run(input Input) error
	Run_Generate(input Input_Generate) error
	Run_GenerateDart3(input Input_GenerateDart3) error
	Run_GenerateDocs(input Input_GenerateDocs) error
	Run_GenerateGolang(input Input_GenerateGolang) error
	Run_GenerateKotlin(input Input_GenerateKotlin) error
	Run_GeneratePython3(input Input_GeneratePython3) error
	Run_GenerateTypescript(input Input_GenerateTypescript) error
	Run_Version(input Input_Version) error
}

func Run(handler CLIHandler, args []string) error {
	subcommandPath, options, arguments := resolveArgs(args)
	switch strings.Join(subcommandPath, " ") {
	case "":
		var input Input
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run(input)

	case "generate":
		var input Input_Generate
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Generate(input)

	case "generate dart3":
		var input Input_GenerateDart3
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GenerateDart3(input)

	case "generate docs":
		var input Input_GenerateDocs
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GenerateDocs(input)

	case "generate golang":
		var input Input_GenerateGolang
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GenerateGolang(input)

	case "generate kotlin":
		var input Input_GenerateKotlin
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GenerateKotlin(input)

	case "generate python3":
		var input Input_GeneratePython3
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GeneratePython3(input)

	case "generate typescript":
		var input Input_GenerateTypescript
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_GenerateTypescript(input)

	case "version":
		var input Input_Version
		input.resolveInput(subcommandPath, options, arguments)
		return handler.Run_Version(input)
	}
	return nil
}

type Input struct {
	Opt_Help   bool
	Subcommand []string
	Options    []string
	Arguments  []string

	ErrorMessage string
}

func (input *Input) resolveInput(subcommand, options, arguments []string) {
	*input = Input{Opt_Help: false,
		Subcommand: subcommand,
		Options:    options,
		Arguments:  arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_Generate struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_Generate) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Generate{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GenerateDart3 struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GenerateDart3) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GenerateDart3{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GenerateDocs struct {
	Opt_Format     string
	Opt_Help       bool
	Opt_OutPath    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GenerateDocs) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GenerateDocs{Opt_Format: "text",
		Opt_Help:       false,
		Opt_OutPath:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-format", "-f":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Format = v.(string)
			}

		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GenerateGolang struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_Package    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GenerateGolang) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GenerateGolang{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_Package:    "main",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-package":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Package = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GenerateKotlin struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_Package    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GenerateKotlin) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GenerateKotlin{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_Package:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-package":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Package = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GeneratePython3 struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GeneratePython3) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GeneratePython3{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_GenerateTypescript struct {
	Opt_Help       bool
	Opt_OutPath    string
	Opt_SchemaPath string
	Subcommand     []string
	Options        []string
	Arguments      []string

	ErrorMessage string
}

func (input *Input_GenerateTypescript) resolveInput(subcommand, options, arguments []string) {
	*input = Input_GenerateTypescript{Opt_Help: false,
		Opt_OutPath:    "",
		Opt_SchemaPath: "",
		Subcommand:     subcommand,
		Options:        options,
		Arguments:      arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		case "-out-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_OutPath = v.(string)
			}

		case "-schema-path":
			if !cut {
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
			}
			if v, err := parseValue("string", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_SchemaPath = v.(string)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}

type Input_Version struct {
	Opt_Help   bool
	Subcommand []string
	Options    []string
	Arguments  []string

	ErrorMessage string
}

func (input *Input_Version) resolveInput(subcommand, options, arguments []string) {
	*input = Input_Version{Opt_Help: false,
		Subcommand: subcommand,
		Options:    options,
		Arguments:  arguments,
	}

	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		case "-help", "-h":
			if !cut {
				lit = "true"
			}
			if v, err := parseValue("bool", lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			} else {
				input.Opt_Help = v.(bool)
			}

		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := 0
	func(...any) {}(expectedArgs)
}
func resolveArgs(args []string) (subcommandPath []string, options []string, arguments []string) {
	if len(args) == 0 {
		panic("command line arguments are too few")
	}
	subcommandSet := map[string]bool{
		"": true, "generate": true, "generate dart3": true, "generate docs": true, "generate golang": true, "generate kotlin": true, "generate python3": true, "generate typescript": true, "version": true,
	}

	subcommandPath, options, arguments = []string{}, []string{}, []string{}
	for _, arg := range args[1:] {
		if arg == "--" {
			break
		}
		pathLiteral := strings.Join(append(append([]string{}, subcommandPath...), arg), " ")
		if !subcommandSet[pathLiteral] {
			break
		}
		subcommandPath = append(subcommandPath, arg)
	}

	restArgs := args[1+len(subcommandPath):]
	for idx, arg := range restArgs {
		if arg == "--" {
			arguments = append(arguments, restArgs[idx+1:]...)
			break
		}
		if strings.HasPrefix(arg, "-") {
			options = append(options, arg)
		} else {
			arguments = append(arguments, arg)
		}
	}

	return subcommandPath, options, arguments
}

func parseValue(typ string, strValue ...string) (dst any, err error) {
	switch typ {
	case "[]bool":
		val := make([]bool, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("bool", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []bool: %w", str, err)
			}
			val[idx] = v.(bool)
		}
		return val, nil
	case "[]int64":
		val := make([]int64, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("int64", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []int64: %w", str, err)
			}
			val[idx] = v.(int64)
		}
		return val, nil
	case "[]string":
		val := make([]string, len(strValue))
		for idx, str := range strValue {
			var v any
			if v, err = parseValue("string", str); err != nil {
				return nil, fmt.Errorf("fail to parse %#v as []string: %w", str, err)
			}
			val[idx] = v.(string)
		}
		return val, nil
	case "bool":
		switch strings.ToLower(strValue[0]) {
		default:
			return nil, fmt.Errorf("fail to parse %q as bool: unknown value", strValue[0])
		case "true", "1", "t":
			return true, nil
		case "false", "0", "f":
			return false, nil
		}
	case "int64":
		val, err := strconv.ParseInt(strValue[0], 0, 64)
		if err != nil {
			return nil, fmt.Errorf("fail to parse %q as int64: %w", strValue[0], err)
		}
		return val, nil
	case "string":
		return strValue[0], nil
	}

	return nil, fmt.Errorf("unknown type %q", typ)
}

func GetVersion() string {
	return "2.0.0-alpha.1"
}
func GetProgram() string {
	return "cyamli"
}
func GetDoc(subcommands []string) string {
	switch strings.Join(subcommands, " ") {
	case "":
		return "cyamli \n\n    Description:\n        A command line tool to generate CLI for your app from YAML-based schema.\n\n    Syntax:\n        $ cyamli  [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n    Subcommands:\n        generate:\n            holds subcommands to generate CLI code.\n\n        version:\n            shows version of this app.\n\n\n"

	case "generate":
		return "cyamli generate\n\n    Description:\n        holds subcommands to generate CLI code.\n\n    Syntax:\n        $ cyamli generate [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n    Subcommands:\n        dart3:\n            generates CLI for your app written in Dart.\n\n        docs:\n            generates documentation for your CLI app.\n\n        golang:\n            generates CLI for your app written in Go.\n\n        kotlin:\n            generates CLI for your app written in Kotlin.\n\n        python3:\n            generates CLI for your app written in Python3.\n\n        typescript:\n            generates CLI for your app written in TypeScript.\n\n\n"

	case "generate dart3":
		return "cyamli generate dart3\n\n    Description:\n        generates CLI for your app written in Dart.\n\n    Syntax:\n        $ cyamli generate dart3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "generate docs":
		return "cyamli generate docs\n\n    Description:\n        generates documentation for your CLI app.\n\n    Syntax:\n        $ cyamli generate docs [<option>]...\n\n    Options:\n        -format=<string>, -f=<string>  (default=\"text\"):\n            specifies output format of the documentation in text or markdown.\n\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "generate golang":
		return "cyamli generate golang\n\n    Description:\n        generates CLI for your app written in Go.\n\n    Syntax:\n        $ cyamli generate golang [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"main\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "generate kotlin":
		return "cyamli generate kotlin\n\n    Description:\n        generates CLI for your app written in Kotlin.\n\n    Syntax:\n        $ cyamli generate kotlin [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -package=<string>  (default=\"\"):\n            package name where the generated file will be placed.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "generate python3":
		return "cyamli generate python3\n\n    Description:\n        generates CLI for your app written in Python3.\n\n    Syntax:\n        $ cyamli generate python3 [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "generate typescript":
		return "cyamli generate typescript\n\n    Description:\n        generates CLI for your app written in TypeScript.\n\n    Syntax:\n        $ cyamli generate typescript [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n        -out-path=<string>  (default=\"\"):\n            if specified then creates a file at the path and writes generated code, otherwise outputs to stdout.\n\n        -schema-path=<string>  (default=\"\"):\n            if specified then reads schema file from the path, otherwise reads from stdin.\n\n\n"

	case "version":
		return "cyamli version\n\n    Description:\n        shows version of this app.\n\n    Syntax:\n        $ cyamli version [<option>]...\n\n    Options:\n        -help[=<boolean>], -h[=<boolean>]  (default=false):\n            shows description of this app.\n\n\n"
	default:
		panic(fmt.Sprintf(`invalid subcommands: %v`, subcommands))
	}
}
