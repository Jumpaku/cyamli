// Code generated by {{.Generator}}, DO NOT EDIT.
#include "{{.HeaderFile}}"
#include <algorithm>
#include <cctype>
#include <string>
#include <tuple>
#include <cstdint>
#include <stdexcept>

namespace {{.Namespace}} {

namespace {

// Helper functions
std::string to_lower(std::string const &s) {
    std::string r = s;
    std::transform(r.begin(), r.end(), r.begin(), [](char const c){ return std::tolower(c); });
    return r;
}

std::string join(std::vector<std::string> const &v, std::string const &sep) {
    std::string result;
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            result += sep;
        }
        result +=  v[i];
    }
    return result;
}

template <typename T, typename ...Args>
T parseValue(Args const &...strValue);

template <>
bool parseValue<bool>(std::string const &strValue) {
    auto lower = to_lower(strValue);
    if (lower == "true" || lower == "1" || lower == "t") {
        return true;
    }
    if (lower == "false" || lower == "0" || lower == "f") {
        return false;
    }
    throw std::runtime_error("fail to parse empty value as bool");
}

template <>
std::int64_t parseValue<std::int64_t>(std::string const &strValue) {
    return static_cast<std::int64_t>(std::stoll(strValue));
}

template <>
std::string parseValue<std::string>(std::string const &strValue) {
    return strValue;
}

template <>
std::vector<bool> parseValue<std::vector<bool>>(std::vector<std::string> const &strValue) {
    std::vector<bool> result;
    for (const auto& val : strValue) {
        result.push_back(parseValue<bool>(val));
    }
    return result;
}

template <>
std::vector<std::int64_t> parseValue<std::vector<std::int64_t>>(std::vector<std::string> const &strValue) {
    std::vector<std::int64_t> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::int64_t>(val));
    }
    return result;
}

template <>
std::vector<std::string> parseValue<std::vector<std::string>>(std::vector<std::string> const &strValue) {
    std::vector<std::string> result;
    for (const auto& val : strValue) {
        result.emplace_back(parseValue<std::string>(val));
    }
    return result;
}

} // namespace

std::tuple<std::vector<std::string>, std::vector<std::string>, std::vector<std::string>>
resolveArgs(std::vector<std::string> const &args) {
    if (args.empty()) {
        throw std::runtime_error("command line arguments are too few");
    }
    std::vector<std::string> subcommandSet = {
        {{range .CommandList}}{{.PathLiteral}},{{end}}
    };
    std::vector<std::string> subcommandPath, options, arguments;
    for (size_t i = 1; i < args.size(); ++i) {
        if (args[i] == "--") {
            break;
        }
        std::string pathLiteral = join(subcommandPath, " ");
        if (!pathLiteral.empty()) pathLiteral += " ";
        pathLiteral += args[i];
        if (std::find(subcommandSet.begin(), subcommandSet.end(), pathLiteral) == subcommandSet.end()){
            break;
        }
        subcommandPath.emplace_back(args[i]);
    }
    auto restArgs = std::vector<std::string>(args.begin() + 1 + subcommandPath.size(), args.end());
    for (size_t idx = 0; idx < restArgs.size(); ++idx) {
        auto const &arg = restArgs[idx];
        if (arg == "--") {
            arguments.insert(arguments.end(), restArgs.begin() + idx + 1, restArgs.end());
            break;
        }
        if (arg.size() > 0 && arg[0] == '-') {
            options.emplace_back(arg);
        } else {
            arguments.emplace_back(arg);
        }
    }
    return std::make_tuple(subcommandPath, options, arguments);
};
void Run(CLIHandler& handler, int argc, const char *argv[]) {
    std::vector<std::string> args;
    for (int i = 0; i < argc; ++i) {
        args.emplace_back(argv[i]);
    }
    auto tup = resolveArgs(args);
    auto const &subcommandPath = std::get<0>(tup);
    auto const &options = std::get<1>(tup);
    auto const &arguments = std::get<2>(tup);
    std::string subcommandKey = join(subcommandPath, " ");
    // Dispatch
    {{range .CommandList}}
    if (subcommandKey == {{.PathLiteral}}) {
        {{.HandlerInputType}} input;
        input.resolveInput(subcommandPath, options, arguments);
        handler.{{.HandlerMethodName}}(input);
        return;
    }
    {{end}}
}

{{range $Index, $Command := .CommandList}}
void {{.HandlerInputType}}::resolveInput(std::vector<std::string> const &subcommand, std::vector<std::string> const &options, std::vector<std::string> const &arguments) {
    // Set defaults
    {{range $Index, $Option := .Options -}}
    this->{{.InputFieldName}} = {{$Option.InputFieldInit}};
    {{end}}
    this->Subcommand = subcommand;
    this->Options = options;
    this->Arguments = arguments;
    this->ErrorMessage.clear();
    for (const auto& arg : this->Options) {
        auto pos = arg.find('=');
        bool cut = pos != std::string::npos;
        std::string optName = arg.substr(0, pos);
        std::string lit = pos != std::string::npos ? arg.substr(pos + 1) : std::string("");
        if (false) {}
        {{- range $Index, $Option := .Options}}
        else if (optName == "{{.Option}}"{{if .ShortOption}} || optName == "{{.ShortOption}}"{{end}}) {
            if (!cut) {
                {{if or (eq $Option.InputFieldType "bool") (eq $Option.InputFieldType "std::vector<bool>") -}}
                lit = "true";
                {{- else -}}
                this->ErrorMessage = "value is not specified to option '" + optName + "'";
                return;
                {{- end}}
            }
            try {
				{{if $Option.Repeated -}}
				this->{{$Option.InputFieldName}}.emplace_back(parseValue<{{.InputFieldType}}>(lit));
				{{- else -}}
				this->{{$Option.InputFieldName}} = parseValue<{{.InputFieldType}}>(lit);
				{{- end}}
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        {{if .Negation}}else if (optName == "-no{{.Option}}") {
            if (!cut) {
                lit = "true";
            }
            try {
				{{if $Option.Repeated -}}
				this->{{$Option.InputFieldName}}.emplace_back(!parseValue<{{.InputFieldType}}>(lit));
				{{- else -}}
				this->{{$Option.InputFieldName}} = !parseValue<{{.InputFieldType}}>(lit);
				{{- end}}
            } catch (const std::exception& e) {
                this->ErrorMessage = std::string("value '") + lit + "' is not assignable to option '" + optName + "'";
                return;
            }
        }
        {{end}}
        {{end}}
        else {
            this->ErrorMessage = "unknown option '" + optName + "'";
            return;
        }
    }

    int expectedArgs = {{len .Arguments}};
    {{- range $Index, $Argument := .Arguments}}
    {{if $Argument.Variadic -}}
    if (this->Arguments.size() < {{$Index}}) {
        this->ErrorMessage = "too few arguments: required at least " + std::to_string(expectedArgs-1) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->{{.InputFieldName}} = parseValue<{{$Argument.InputFieldType}}>(std::vector<std::string>(this->Arguments.begin() + {{$Index}}, this->Arguments.end()));
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + join(std::vector<std::string>(this->Arguments.begin() + {{$Index}}, this->Arguments.end()), ", ") + "': " + e.what();
        return;
    }
    {{- else -}}
    if (this->Arguments.size() <= {{$Index}}) {
        this->ErrorMessage = "too few arguments: required " + std::to_string(expectedArgs) + ", got " + std::to_string(this->Arguments.size());
        return;
    }
    try {
        this->{{.InputFieldName}} = parseValue<{{$Argument.InputFieldType}}>(this->Arguments[{{$Index}}]);
    } catch (const std::exception& e) {
        this->ErrorMessage = "fail to parse argument '" + this->Arguments[{{$Index}}] + "': " + e.what();
        return;
    }
    {{- end}}
    {{end}}
}

{{end -}}

std::string GetVersion() {
    return "{{.Program.Version}}";
}
std::string GetProgram() {
    return "{{.Program.Name}}";
}
std::string GetDoc(std::vector<std::string> const &subcommands) {
    std::string key = join(subcommands, " ");
    {{range .CommandList}}
    if (key == {{.PathLiteral}}) return {{.DocText}};
    {{end}}
    throw std::runtime_error("invalid subcommands: " + key);
}

} // namespace
