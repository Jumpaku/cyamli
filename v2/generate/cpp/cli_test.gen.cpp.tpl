// Code generated by {{.Generator}}, DO NOT EDIT.
#include "cli.gen.h"
#include <iostream>
#include <vector>
#include <string>
#include <memory>
#include <cstdint>
#include <stdexcept>

template <typename T>
std::ostream& operator<<(std::ostream& os, std::vector<T> const &v) {
    os << "[";
    for (size_t i = 0; i < v.size(); ++i) {
        if (i > 0) {
            os << ", ";
        }
        os << v[i];
    }
    return os << "]";
}

#define TEST_ASSERT_EQUAL(name, got, want) \
     if ((got) != (want)) { \
        std::cout << "[FAIL] " << (std::string(__func__) + " at " + std::string(__FILE__) + ":" + std::to_string(__LINE__)) << ": " << (name) << std::endl; \
        std::cout << "Want = " << (want) << std::endl; \
        std::cout << "Got  = " << (got) << std::endl; \
        std::exit(1); \
    }

namespace {{.Namespace}} {

struct CLIHandlerMock : public CLIHandler {
    void* gotInput = nullptr;
    {{range $Index, $Command := .CommandList}}
    void {{.HandlerMethodName}}(const {{.HandlerInputType}}& input) override {
        gotInput = (void *)new {{.HandlerInputType}}(input);
    }
    {{end}}
};

{{range $Index, $Command := .CommandList}}
void test_{{.HandlerMethodName}}() {
    struct TestCase {
        std::string name;
        std::vector<std::string> args;
        {{.HandlerInputType}} wantInput;
    };
    std::vector<TestCase> testcases = {
        // command-line-arguments
        {"command-line-arguments",
            {"", {{range .Path}}"{{.}}", {{end}}{{range $Index, $Option := .Options}}"{{$Option.Option}}=0",{{end}}"--",{{range $Index, $Argument := .Arguments}}"0",{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{if eq $Option.Type "integer"}}{{if $Option.Repeated}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Option.Type "boolean"}}{{if $Option.Repeated}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Option.Repeated}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
        // default-options
        {"default-options",
            {"", {{range .Path}}"{{.}}", {{end}}"--",{{range $Index, $Argument := .Arguments}}"0",{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{.InputFieldInit}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
        // short-options
        {"short-options",
            {"", {{range .Path}}"{{.}}", {{end}}{{range $Index, $Option := .Options}}"{{if $Option.ShortOption}}{{$Option.ShortOption}}{{else}}{{$Option.Option}}{{end}}=0",{{end}}"--",{{range $Index, $Argument := .Arguments}}"0",{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{if eq $Option.Type "integer"}}{{if $Option.Repeated}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Option.Type "boolean"}}{{if $Option.Repeated}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Option.Repeated}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
        // negated-options
        {"negated-options",
            {"", {{range .Path}}"{{.}}", {{end}}{{range $Index, $Option := .Options}}"{{if $Option.Negation}}-no{{$Option.Option}}=1{{else}}{{$Option.Option}}=0{{end}}",{{end}}"--",{{range $Index, $Argument := .Arguments}}"0",{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{if eq $Option.Type "integer"}}{{if $Option.Repeated}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Option.Type "boolean"}}{{if $Option.Repeated}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Option.Repeated}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
        // variadic-arguments-zero
        {"variadic-arguments-zero",
            {"", {{range .Path}}"{{.}}", {{end}}{{range $Index, $Option := .Options}}"{{if $Option.Negation}}-no{{$Option.Option}}=1{{else}}{{$Option.Option}}=0{{end}}",{{end}}"--",{{range $Index, $Argument := .Arguments}}{{if not $Argument.Variadic}}"0",{{end}}{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{if eq $Option.Type "integer"}}{{if $Option.Repeated}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Option.Type "boolean"}}{{if $Option.Repeated}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Option.Repeated}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
        // variadic-arguments-two
        {"variadic-arguments-two",
            {"", {{range .Path}}"{{.}}", {{end}}{{range $Index, $Option := .Options}}"{{if $Option.Negation}}-no{{$Option.Option}}=1{{else}}{{$Option.Option}}=0{{end}}",{{end}}"--",{{range $Index, $Argument := .Arguments}}"0"{{if $Argument.Variadic}}, "0"{{end}},{{end}}},
            []{
                {{.HandlerInputType}} v;
                {{range $Index, $Option := .Options}}
                v.{{.InputFieldName}} = {{if eq $Option.Type "integer"}}{{if $Option.Repeated}}std::vector<std::int64_t>{0}{{else}}0{{end}}{{else if eq $Option.Type "boolean"}}{{if $Option.Repeated}}std::vector<bool>{false}{{else}}false{{end}}{{else}}{{if $Option.Repeated}}std::vector<std::string>{"0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                {{range $Index, $Argument := .Arguments}}
                v.{{.InputFieldName}} = {{if eq $Argument.Type "integer"}}{{if $Argument.Variadic}}std::vector<std::int64_t>{0, 0}{{else}}0{{end}}{{else if eq $Argument.Type "boolean"}}{{if $Argument.Variadic}}std::vector<bool>{false, false}{{else}}false{{end}}{{else}}{{if $Argument.Variadic}}std::vector<std::string>{"0", "0"}{{else}}"0"{{end}}{{end}};
                {{end}}
                return v;
            }()
        },
    };
    for (const auto& tc : testcases) {
        CLIHandlerMock mock;
        std::vector<std::string> argv = tc.args;
        int argc = argv.size();
        std::vector<const char*> argv_c(argc);
        for (int i = 0; i < argc; ++i) argv_c[i] = argv[i].c_str();
        Run(mock, argc, argv_c.data());
        auto got = static_cast<{{.HandlerInputType}} *>(mock.gotInput);
        auto want = tc.wantInput;
        TEST_ASSERT_EQUAL(tc.name + ": input is nullptr", true, got != nullptr);
        TEST_ASSERT_EQUAL(tc.name + ": ErrorMessage is not empty", true, got->ErrorMessage.empty());

        {{range $Index, $Option := .Options}}
        TEST_ASSERT_EQUAL(tc.name + ": option: {{.Option}}", want.{{.InputFieldName}}, got->{{.InputFieldName}});
        {{end}}
        {{range $Index, $Argument := .Arguments}}
        TEST_ASSERT_EQUAL(tc.name + ": argument: {{.Name}}", want.{{.InputFieldName}}, got->{{.InputFieldName}});
        {{end}}
    }
    std::cout << "[PASS] {{.HandlerMethodName}}" << std::endl;
}
{{end}}

} // namespace {{.Namespace}}

int main() {
    {{$Namespace := .Namespace}}
    {{range $Index, $Command := .CommandList}}
    {{$Namespace}}::test_{{.HandlerMethodName}}();
    {{end}}
    std::cout << "All tests passed." << std::endl;
    return 0;
}

