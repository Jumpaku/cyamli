// Code generated by {{.Generator}}, DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.Linq;

namespace {{.Namespace}} {

public interface ICLIHandler {
    {{ range $Index, $Command := .CommandList -}}
    void {{.HandlerMethodName}}(CLI.{{.HandlerInputType}} input);
    {{end}}
}

public static class CLI {
    public static void Run(ICLIHandler handler, string[] args) {
        var (subcommandPath, options, arguments) = ResolveArgs(args);
        switch (string.Join(" ", subcommandPath)) {
            {{range .CommandList}}
            case {{.PathLiteral}}:
                {
                    var input = new {{.HandlerInputType}}();
                    input.ResolveInput(subcommandPath, options, arguments);
                    handler.{{.HandlerMethodName}}(input);
                }
                break;
            {{end -}}
        }
    }

    {{range $Index, $Command := .CommandList}}
    public class {{.HandlerInputType}} {
        {{range $Index, $Option := .Options -}}
        public {{if eq $Option.InputFieldType "bool"}}bool{{else if eq $Option.InputFieldType "int64"}}long{{else if eq $Option.InputFieldType "string"}}string{{else if eq $Option.InputFieldType "[]bool"}}List<bool>{{else if eq $Option.InputFieldType "[]int64"}}List<long>{{else if eq $Option.InputFieldType "[]string"}}List<string>{{end}} {{.InputFieldName}} { get; set; }
        {{end}}
        {{- range $Index, $Argument := .Arguments -}}
        public {{if eq $Argument.InputFieldType "bool"}}bool{{else if eq $Argument.InputFieldType "int64"}}long{{else if eq $Argument.InputFieldType "string"}}string{{else if eq $Argument.InputFieldType "[]bool"}}List<bool>{{else if eq $Argument.InputFieldType "[]int64"}}List<long>{{else if eq $Argument.InputFieldType "[]string"}}List<string>{{end}} {{.InputFieldName}} { get; set; }
        {{end}}
        public List<string> Subcommand { get; set; }
        public List<string> Options { get; set; }
        public List<string> Arguments { get; set; }
        public string ErrorMessage { get; set; }

        public void ResolveInput(List<string> subcommand, List<string> options, List<string> arguments) {
            // Set defaults
            {{range $Index, $Option := .Options -}}
            this.{{.InputFieldName}} = {{$Option.InputFieldInit}};
            {{end}}
            this.Subcommand = subcommand;
            this.Options = options;
            this.Arguments = arguments;
            this.ErrorMessage = null;

            foreach (var arg in this.Options) {
                var cut = arg.Split('=');
                var optName = cut[0];
                var lit = cut.Length > 1 ? cut[1] : null;
                switch (optName) {
                {{- range $Index, $Option := .Options}}
                case "{{.Option}}":
                {{if .ShortOption}}case "{{.ShortOption}}":{{end}}
                    {
                        if (lit == null) {
                            {{if or (eq $Option.InputFieldType "bool") (eq $Option.InputFieldType "[]bool") -}}
                            lit = "true";
                            {{- else -}}
                            this.ErrorMessage = $"value is not specified to option {optName}";
                            return;
                            {{- end}}
                        }
                        try {
                            var v = ParseValue("{{.InputFieldType}}", lit);
                            {{if .Repeated -}}
                            if (this.{{.InputFieldName}} == null) this.{{.InputFieldName}} = new List<{{if eq $Option.Type "integer"}}long{{else if eq $Option.Type "boolean"}}bool{{else}}string{{end}}>();
                            this.{{.InputFieldName}}.Add(({{if eq $Option.Type "integer"}}long{{else if eq $Option.Type "boolean"}}bool{{else}}string{{end}})v);
                            {{- else -}}
                            this.{{.InputFieldName}} = ({{if eq $Option.Type "integer"}}long{{else if eq $Option.Type "boolean"}}bool{{else}}string{{end}})v;
                            {{- end}}
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                {{if .Negation}}case "-no{{.Option}}":
                    {
                        if (lit == null) lit = "true";
                        try {
                            var v = ParseValue("{{.InputFieldType}}", lit);
                            {{if .Repeated -}}
                            if (this.{{.InputFieldName}} == null) this.{{.InputFieldName}} = new List<{{if eq $Option.Type "integer"}}long{{else if eq $Option.Type "boolean"}}bool{{else}}string{{end}}>();
                            this.{{.InputFieldName}}.Add(!((bool)v));
                            {{- else -}}
                            this.{{.InputFieldName}} = !((bool)v);
                            {{- end}}
                        } catch {
                            this.ErrorMessage = $"value {lit} is not assignable to option {optName}";
                            return;
                        }
                    }
                    break;
                {{end}}
                {{end -}}
                default:
                    {
                        this.ErrorMessage = $"unknown option {optName}";
                    }
                    return;
                }
            }

            var expectedArgs = {{len .Arguments}};
            {{range $Index, $Argument := .Arguments}}
            {{if $Argument.Variadic -}}
            if (this.Arguments.Count < {{$Index}}) {
                this.ErrorMessage = $"too few arguments: required at least {expectedArgs-1}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("{{.InputFieldType}}", this.Arguments.Skip({{$Index}}).ToArray());
                this.{{.InputFieldName}} = ({{if eq $Argument.Type "integer"}}List<long>{{else if eq $Argument.Type "boolean"}}List<bool>{{else}}List<string>{{end}})v;
            } catch {
                this.ErrorMessage = $"values [{string.Join(" ", this.Arguments.Skip({{$Index}}))}] are not assignable to arguments at [{{$Index}}:]";
                return;
            }
            {{- else -}}
            if (this.Arguments.Count <= {{$Index}}) {
                this.ErrorMessage = $"too few arguments: required {expectedArgs}, got {this.Arguments.Count}";
                return;
            }
            try {
                var v = ParseValue("{{.InputFieldType}}", this.Arguments.Skip({{$Index}}).ToArray());
                this.{{.InputFieldName}} = ({{if eq $Argument.Type "integer"}}long{{else if eq $Argument.Type "boolean"}}bool{{else}}string{{end}})v;
            } catch {
                this.ErrorMessage = $"value {this.Arguments[{{$Index}}]} is not assignable to argument at [{{$Index}}]";
                return;
            }
            {{- end}}
            {{end}}
        }
    }
    {{end}}

    private static (List<string> subcommandPath, List<string> options, List<string> arguments) ResolveArgs(string[] args) {
        if (args.Length == 0) throw new Exception("command line arguments are too few");
        var subcommandSet = new HashSet<string> {
            {{range .CommandList}}{{.PathLiteral}},{{end}}
        };
        var subcommandPath = new List<string>();
        var options = new List<string>();
        var arguments = new List<string>();
        for (int i = 1; i < args.Length; i++) {
            if (args[i] == "--") break;
            var pathLiteral = string.Join(" ", subcommandPath.Concat(new[]{args[i]}));
            if (!subcommandSet.Contains(pathLiteral)) break;
            subcommandPath.Add(args[i]);
        }
        var restArgs = args.Skip(1 + subcommandPath.Count).ToArray();
        for (int idx = 0; idx < restArgs.Length; idx++) {
            var arg = restArgs[idx];
            if (arg == "--") {
                arguments.AddRange(restArgs.Skip(idx + 1));
                break;
            }
            if (arg.StartsWith("-")) options.Add(arg);
            else arguments.Add(arg);
        }
        return (subcommandPath, options, arguments);
    }

    private static object ParseValue(string typ, params string[] strValue) {
        switch (typ) {
            case "[]bool":
                return strValue.Select(s => (bool)ParseValue("bool", s)).ToList();
            case "[]int64":
                return strValue.Select(s => (long)ParseValue("int64", s)).ToList();
            case "[]string":
                return strValue.Select(s => (string)ParseValue("string", s)).ToList();
            case "bool":
                switch (strValue[0].ToLower()) {
                    case "true": case "1": case "t": return true;
                    case "false": case "0": case "f": return false;
                    default: throw new Exception($"fail to parse {strValue[0]} as bool: unknown value");
                }
            case "int64":
                return long.Parse(strValue[0]);
            case "string":
                return strValue[0];
        }
        throw new Exception($"unknown type {typ}");
    }

    public static string GetVersion() => "{{.Program.Version}}";
    public static string GetProgram() => "{{.Program.Name}}";
    public static string GetDoc(List<string> subcommands) {
        switch (string.Join(" ", subcommands)) {
        {{- range .CommandList}}
            case {{.PathLiteral}}:
                return {{.DocText}};
        {{end -}}
            default:
                throw new Exception($"invalid subcommands: {string.Join(", ", subcommands)}");
        }
    }
}

} // namespace

