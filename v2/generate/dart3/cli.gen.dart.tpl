// Code generated by {{.Generator}}, DO NOT EDIT.
// ignore_for_file: non_constant_identifier_names

import 'dart:convert';

/// Interface for CLI handlers
abstract class CLIHandler {
  {{- range $Index, $Command := .CommandList}}
  Future<void> {{$Command.HandlerMethodName}}({{$Command.HandlerInputType}} input);
  {{- end}}
}

/// Entry point for the CLI application
Future<void> run(CLIHandler handler, List<String> args) async {
  final (path, restArgs) = resolveSubcommand(args);
  final subcommandPath = path;

  switch (subcommandPath.join(' ')) {
  {{- range .CommandList}}
  case {{.PathLiteral}}:
    final input = {{.HandlerInputType}}();
    input.resolveInput(restArgs);
    await handler.{{.HandlerMethodName}}(input);
    break;
  {{- end}}
  }
}

{{range $Index, $Command := .CommandList}}
/// Input class for {{$Command.HandlerMethodName}}
class {{$Command.HandlerInputType}} {
  {{- range $Index, $Option := $Command.Options -}}
  {{$Option.InputFieldType}} {{$Option.InputFieldName}} = {{$Option.InputFieldInit}};
  {{end -}}
  {{- range $Index, $Argument := $Command.Arguments -}}
  {{$Argument.InputFieldType}}? {{$Argument.InputFieldName}};
  {{end -}}

  List<String> subcommand = [];
  List<String> options = [];
  List<String> arguments = [];

  String? errorMessage;

  /// toString representation of the input
  @override
  String toString() {
      final buffer = StringBuffer();
      buffer.writeln('Subcommand: [${subcommand.join(' ')}]');
      buffer.writeln('Options: [${options.join(', ')}]');
      buffer.writeln('Arguments: [${arguments.join(', ')}]');
      {{- range $Index, $Option := $Command.Options -}}
      buffer.writeln('{{$Option.InputFieldName}}: ${{$Option.InputFieldName}}');
      {{end -}}
      {{- range $Index, $Argument := $Command.Arguments -}}
      buffer.writeln('{{$Argument.InputFieldName}}: ${{$Argument.InputFieldName}}');
      {{end -}}
      if (errorMessage != null) {
        buffer.writeln('Error: $errorMessage');
      }
      return buffer.toString();
    }
  void resolveInput(List<String> restArgs) {
    subcommand = {{$Command.PathLiteral}}.split(' ');

    for (int idx = 0; idx < restArgs.length; idx++) {
      final arg = restArgs[idx];
      if (arg == '--') {
        arguments.addAll(restArgs.sublist(idx + 1));
        break;
      }
      if (arg.startsWith('-')) {
        options.add(arg);
      } else {
        arguments.add(arg);
      }
    }

    for (final arg in options) {
      final cut = arg.indexOf("=");
      String optName;
      String? lit;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      }else{
        optName = arg;
      }

      switch (optName) {
      {{- range $Index, $Option := $Command.Options}}
      case '{{$Option.Option}}':
        if (cut < 0) {
          {{if eq $Option.InputFieldType "bool" -}}
          lit = 'true';
          {{- else -}}
          errorMessage = 'Value is not specified to option "$optName"';
          return;
          {{- end}}
        }
        {{if $Option.Repeated -}}
        try {
          final v = parseValue(lit!, '{{$Option.InputFieldType}}');
          {{$Option.InputFieldName}}.addAll(v);
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        {{- else -}}
        try {
          {{$Option.InputFieldName}} = parseValue(lit!, '{{$Option.InputFieldType}}');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        {{- end}}
        break;
      {{if $Option.ShortOption}}
      case '{{$Option.ShortOption}}':
        if (cut < 0) {
          {{if eq $Option.InputFieldType "bool" -}}
          lit = 'true';
          {{- else -}}
          errorMessage = 'Value is not specified to option "$optName"';
          return;
          {{- end}}
        }
        {{if $Option.Repeated -}}
        try {
          final v = parseValue(lit!, '{{$Option.InputFieldType}}');
          {{$Option.InputFieldName}}.addAll(v);
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        {{- else -}}
        try {
          {{$Option.InputFieldName}} = parseValue(lit!, '{{$Option.InputFieldType}}');
        } catch (e) {
          errorMessage = 'Value "$lit" is not assignable to option "$optName"';
          return;
        }
        {{- end}}
        break;
      {{end}}
      {{end -}}
      default:
        errorMessage = 'Unknown option "$optName"';
        return;
      }
    }

    final expectedArgs = {{len $Command.Arguments}};

    {{- range $Index, $Argument := .Arguments}}
    {{if $Argument.Variadic -}}
    if (arguments.length < {{$Index}}) {
      errorMessage = 'Too few arguments: required at least ${expectedArgs - 1}, got ${arguments.length}';
      return;
    }
    try {
      {{$Argument.InputFieldName}} = arguments.sublist({{$Index}}).map((s) => parseValue(s, '{{$Argument.InputFieldType}}') as {{$Argument.InputFieldType}}).expand((v)=>v).toList();
    } catch (e) {
      errorMessage = 'Values [${arguments.sublist({{$Index}}).join(" ")}] are not assignable to arguments at [{{$Index}}:]';
      return;
    }
    {{- else -}}
    if (arguments.length <= {{$Index}}) {
      errorMessage = 'Too few arguments: required $expectedArgs, got ${arguments.length}';
      return;
    }
    try {
      {{$Argument.InputFieldName}} = parseValue(arguments[{{$Index}}], '{{$Argument.InputFieldType}}');
    } catch (e) {
      errorMessage = 'Value "${arguments[{{$Index}}]}" is not assignable to argument at [{{$Index}}]';
      return;
    }
    {{- end}}
    {{end -}}
  }
}
{{end -}}

/// Resolves the subcommand from the arguments
(List<String> subcommandPath, List<String> restArgs) resolveSubcommand(List<String> args) {
  final subcommandSet = {
  {{range .CommandList}}  {{.PathLiteral}}: true,{{end}}
  };

  final subcommandPath = <String>[];

  for (final arg in args) {
    if (arg == '--') {
      break;
    }
    final pathLiteral = [...subcommandPath, arg].join(' ');
    if (!subcommandSet.containsKey(pathLiteral)) {
      break;
    }
    subcommandPath.add(arg);
  }

  return (subcommandPath, args.sublist(subcommandPath.length));
}

/// Parses a string value to the specified type
dynamic parseValue(String strValue, String typeName) {
  switch (typeName) {
    case 'List<bool>':
      return [parseValue(strValue, 'bool') as bool];
    case 'List<int>':
      return [parseValue(strValue, 'int') as int];
    case 'List<String>':
      return [parseValue(strValue, 'String') as String];
    case 'bool':
      if (['true', 't', '1'].contains(strValue.toLowerCase())) return true;
      if (['false', 'f', '0'].contains(strValue.toLowerCase())) return false;
      throw FormatException('Failed to parse "$strValue" as bool');
    case 'int':
      try {
        return int.parse(strValue);
      } catch (e) {
        throw FormatException('Failed to parse "$strValue" as int');
      }
    case 'String':
      return strValue;
    default:
      throw FormatException('Unsupported type: $typeName');
  }
}

/// Gets documentation for a subcommand
String getDoc(List<String> subcommands) {
  switch (subcommands.join(' ')) {
  {{- range .CommandList}}
    case {{.PathLiteral}}:
      return {{.DocText}};
  {{end -}}
    default:
      throw Exception('Invalid subcommands: $subcommands');
  }
}
