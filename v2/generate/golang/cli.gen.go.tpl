// Code generated by {{.Generator}}, DO NOT EDIT.
package {{.Package}}

import (
	"fmt"
	"strings"
	"strconv"
)

type CLIHandler interface {
	{{- range $Index, $Command := .CommandList -}}
	{{$Command.HandlerMethodName}}(input {{$Command.HandlerInputType}}) error
	{{end -}}
}

{{/* Entry point */}}
func Run(handler CLIHandler, args []string) error {
	subcommandPath, restArgs := resolveSubcommand(args)
	switch strings.Join(subcommandPath, " ") {
	{{- range .CommandList}}
	case {{.PathLiteral}}:
		var input {{.HandlerInputType}}
		input.resolveInput(restArgs)
		return handler.{{.HandlerMethodName}}(input)
	{{end -}}
	}
	return nil
}

{{range $Index, $Command := .CommandList}}
type {{$Command.HandlerInputType}} struct {
	{{- range $Index, $Option := $Command.Options -}}
	{{$Option.InputFieldName}} {{$Option.InputFieldType}}
	{{end -}}
	{{- range $Index, $Argument := $Command.Arguments -}}
	{{$Argument.InputFieldName}} {{$Argument.InputFieldType}}
	{{end -}}

	Subcommand []string
	Options    []string
	Arguments  []string

	ErrorMessage string
}
func (input *{{$Command.HandlerInputType}}) resolveInput(restArgs []string) {
	*input = {{.HandlerInputType}}{
		{{- range $Index, $Option := $Command.Options -}}
		{{$Option.InputFieldName}}: {{$Option.InputFieldInit}},
		{{end -}}
		Subcommand: strings.Split({{$Command.PathLiteral}}, " "),
	}

	for idx, arg := range restArgs {
		if arg == "--" {
			input.Arguments = append(input.Arguments, restArgs[idx+1:]...)
			break
		}
		if strings.HasPrefix(arg, "-") {
			input.Options = append(input.Options, arg)
		} else {
			input.Arguments = append(input.Arguments, arg)
		}
	}
	for _, arg := range input.Options {
		optName, lit, cut := strings.Cut(arg, "=")
		func(...any) {}(optName, lit, cut)

		switch optName {
		{{- range $Index, $Option := $Command.Options}}
		case "{{$Option.Option}}"{{if $Option.ShortOption}}, "{{$Option.ShortOption}}"{{end}}:
			if !cut {
				{{if eq $Option.InputFieldType "bool" -}}
				lit = "true"
				{{- else -}}
				input.ErrorMessage = fmt.Sprintf("value is not specified to option %q", optName)
				return
				{{- end}}
			}
			{{if $Option.Repeated -}}
			var v {{$Option.InputFieldType}}
			if err := parseValue(&v, lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			}
			input.{{$Option.InputFieldName}} = append(input.{{$Option.InputFieldName}}, v...)
			{{- else -}}
			if err := parseValue(&input.{{$Option.InputFieldName}}, lit); err != nil {
				input.ErrorMessage = fmt.Sprintf("value %q is not assignable to option %q", lit, optName)
				return
			}
			{{- end}}
		{{end -}}
		default:
			input.ErrorMessage = fmt.Sprintf("unknown option %q", optName)
			return
		}
	}

	expectedArgs := {{len $Command.Arguments}}
	func(...any) {}(expectedArgs)

	{{- range $Index, $Argument := .Arguments}}
	{{if $Argument.Variadic -}}
	if len(input.Arguments) < {{$Index}} {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required at least %d, got %d", expectedArgs-1, len(input.Arguments))
		return
	}
	if err := parseValue(&input.{{$Argument.InputFieldName}}, input.Arguments[{{$Index}}:]...); err != nil {
		input.ErrorMessage = fmt.Sprintf("values [%s] are not assignable to arguments at [%d:]", strings.Join(input.Arguments[{{$Index}}:], " "), {{$Index}})
		return
	}
	{{- else -}}
	if len(input.Arguments) <= {{$Index}} {
		input.ErrorMessage = fmt.Sprintf("too few arguments: required %d, got %d", expectedArgs, len(input.Arguments))
		return
	}
	if err := parseValue(&input.{{$Argument.InputFieldName}}, input.Arguments[{{$Index}}]); err != nil {
		input.ErrorMessage = fmt.Sprintf("value %q is not assignable to argument at [%d]", input.Arguments[{{$Index}}], {{$Index}})
		return
	}
	{{- end}}
	{{end -}}
}
{{end -}}

func resolveSubcommand(args []string) (subcommandPath []string, restArgs []string) {
	if len(args) == 0 {
		panic("command line arguments are too few")
	}
	subcommandSet := map[string]bool{
	{{range .CommandList}}	{{.PathLiteral}}: true,{{end}}
	}

	for _, arg := range args[1:] {
		if arg == "--" {
			break
		}
		pathLiteral := strings.Join(append(append([]string{}, subcommandPath...), arg), " ")
		if !subcommandSet[pathLiteral] {
			break
		}
		subcommandPath = append(subcommandPath, arg)
	}

	return subcommandPath, args[1+len(subcommandPath):]
}

func parseValue(dstPtr any, strValue ...string) error {
	switch dstPtr := dstPtr.(type) {
	case *[]bool:
		val := make([]bool, len(strValue))
		for idx, str := range strValue {
			if err := parseValue(&val[idx], str); err != nil {
				return fmt.Errorf("fail to parse %#v as []bool: %w", str, err)
			}
		}
		*dstPtr = val
	case *[]int64:
		val := make([]int64, len(strValue))
		for idx, str := range strValue {
			if err := parseValue(&val[idx], str); err != nil {
				return fmt.Errorf("fail to parse %#v as []int64: %w", str, err)
			}
		}
		*dstPtr = val
	case *[]string:
		val := make([]string, len(strValue))
		for idx, str := range strValue {
			if err := parseValue(&val[idx], str); err != nil {
				return fmt.Errorf("fail to parse %#v as []string: %w", str, err)
			}
		}
		*dstPtr = val
	case *bool:
		val, err := strconv.ParseBool(strValue[0])
		if err != nil {
			return fmt.Errorf("fail to parse %q as bool: %w", strValue[0], err)
		}
		*dstPtr = val
	case *int64:
		val, err := strconv.ParseInt(strValue[0], 0, 64)
		if err != nil {
			return fmt.Errorf("fail to parse %q as int64: %w", strValue[0], err)
		}
		*dstPtr = val
	case *string:
		*dstPtr = strValue[0]
	}
	return nil
}

{{/* Documents */}}
func GetDoc(subcommands []string) string {
	switch strings.Join(subcommands, " ") {
{{- range .CommandList}}
	case {{.PathLiteral}}:
		return {{.DocText}}
{{end -}}
	default:
		panic(fmt.Sprintf(`invalid subcommands: %v`, subcommands))
	}
}
