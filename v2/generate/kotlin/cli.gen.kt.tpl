// Code generated by {{.Generator}}, DO NOT EDIT.
package {{.Package}}

// Interface for CLI handlers
interface CLIHandler {
{{range .CommandList}}
    fun {{.HandlerMethodName}}(input: {{.HandlerInputType}})
{{end}}
}

// Entry point for the CLI application
fun execute(handler: CLIHandler, args: Array<String>) {
    val (subcommandPath, restArgs) = resolveSubcommand(args)

    when (subcommandPath.joinToString(" ")) {
{{range .CommandList}}
        {{.PathLiteral}} -> {
            val input = {{.HandlerInputType}}()
            input.resolveInput(restArgs)
            handler.{{.HandlerMethodName}}(input)
        }
{{end}}
        else -> {}
    }
}

{{range .CommandList}}
// Input class for {{.HandlerMethodName}}
data class {{.HandlerInputType}}(
{{range .Options}}
    var {{.InputFieldName}}: {{.InputFieldType}} = {{.InputFieldInit}},
{{end}}
{{range .Arguments}}
    var {{.InputFieldName}}: {{.InputFieldType}} = {{if .Variadic}}listOf(){{else}}{{if eq .InputFieldType "String"}}""{{else if eq .InputFieldType "Long"}}0L{{else if eq .InputFieldType "Boolean"}}false{{end}}{{end}},
{{end}}

    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(restArgs: List<String>) {
        subcommand = {{.PathLiteral}}.run { if (isEmpty()) listOf() else split(" ") }

        val tempOptions = mutableListOf<String>()
        val tempArguments = mutableListOf<String>()

        var idx = 0
        while (idx < restArgs.size) {
            val arg = restArgs[idx]
            if (arg == "--") {
                tempArguments.addAll(restArgs.subList(idx + 1, restArgs.size))
                break
            }
            if (arg.startsWith("-")) {
                tempOptions.add(arg)
            } else {
                tempArguments.add(arg)
            }
            idx++
        }

        options = tempOptions
        arguments = tempArguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {
{{range .Options}}
                "{{.Option}}"{{if .ShortOption}}, "{{.ShortOption}}"{{end}} -> {
                    if (!hasValue) {
                        {{if eq .InputFieldType "Boolean" -}}
                        {{.InputFieldName}} = true
                        {{- else -}}
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                        {{- end}}
                    } else {
                        {{if .Repeated -}}
                        try {
                            val v = parseString(lit)
                            {{.InputFieldName}} = {{.InputFieldName}} + listOf(v)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- else -}}
                        try {
                            {{.InputFieldName}} = parse{{.InputFieldType}}(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- end}}
                    }
                }
{{end}}
                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        val expectedArgs = {{len .Arguments}}

{{range $Index, $Argument := .Arguments}}
        {{if $Argument.Variadic -}}
        if (arguments.size < {{$Index}}) {
            errorMessage = "Too few arguments: required at least ${expectedArgs - 1}, got ${arguments.size}"
            return
        }
        try {
            {{if eq $Argument.InputFieldType "List<Boolean>" -}}
            {{$Argument.InputFieldName}} = parseArrayBoolean(arguments.subList({{$Index}}, arguments.size))
            {{- else if eq $Argument.InputFieldType "List<Long>" -}}
            {{$Argument.InputFieldName}} = parseArrayLong(arguments.subList({{$Index}}, arguments.size))
            {{- else -}}
            {{$Argument.InputFieldName}} = parseArrayString(arguments.subList({{$Index}}, arguments.size))
            {{- end}}
        } catch (e: Exception) {
            errorMessage = "Values [${arguments.subList({{$Index}}, arguments.size).joinToString(" ")}] are not assignable to arguments at [{{$Index}}:]"
            return
        }
        {{- else -}}
        if (arguments.size <= {{$Index}}) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            {{$Argument.InputFieldName}} = parse{{$Argument.InputFieldType}}(arguments[{{$Index}}])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[{{$Index}}]}\" is not assignable to argument at [{{$Index}}]"
            return
        }
        {{- end}}
{{end}}
    }
}
{{end}}

// Resolves the subcommand from arguments
internal fun resolveSubcommand(args: Array<String>): Pair<List<String>, List<String>> {
    val subcommandSet = mapOf(
{{range .CommandList}}
        {{.PathLiteral}} to true,
{{end}}
    )

    val subcommandPath = mutableListOf<String>()

    for (arg in args) {
        if (arg == "--") {
            break
        }
        val pathLiteral = (subcommandPath + arg).joinToString(" ")
        if (!subcommandSet.containsKey(pathLiteral)) {
            break
        }
        subcommandPath.add(arg)
    }

    return Pair(subcommandPath, args.drop(subcommandPath.size))
}

// Parses a string value to Boolean
internal fun parseBoolean(strValue: String): Boolean {
    return strValue.toBoolean()
}

// Parses a string value to Long
internal fun parseLong(strValue: String): Long {
    return strValue.toLong()
}

// Parses a string value to String
internal fun parseString(strValue: String): String {
    return strValue
}

// Parses a list of string values to a list of Boolean
internal fun parseArrayBoolean(strValues: List<String>): List<Boolean> {
    return strValues.map { parseBoolean(it) }
}

// Parses a list of string values to a list of Long
internal fun parseArrayLong(strValues: List<String>): List<Long> {
    return strValues.map { parseLong(it) }
}

// Parses a list of string values to a list of String
internal fun parseArrayString(strValues: List<String>): List<String> {
    return strValues.map { parseString(it) }
}
fun getVersion(): String {
    return "{{.Program.Version}}"
}
fun getProgram(): String {
    return "{{.Program.Name}}"
}
// Gets documentation for a subcommand
fun getDoc(subcommands: List<String>): String {
    return when (subcommands.joinToString(" ")) {
{{range .CommandList}}
        {{.PathLiteral}} -> {{.DocText}}
{{end}}
        else -> throw IllegalArgumentException("Invalid subcommands: $subcommands")
    }
}
