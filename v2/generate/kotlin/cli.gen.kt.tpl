// Code generated by {{.Generator}}, DO NOT EDIT.
package {{.Package}}

// Interface for CLI handlers
interface CLIHandler {
{{range .CommandList}}
    fun {{.HandlerMethodName}}(input: {{.HandlerInputType}})
{{end}}
}

// Entry point for the CLI application
fun execute(handler: CLIHandler, args: Array<String>) {
    val (subcommandPath, options, arguments) = resolveSubcommand(args)

    when (subcommandPath.joinToString(" ")) {
{{range .CommandList}}
        {{.PathLiteral}} -> {
            val input = {{.HandlerInputType}}()
            input.resolveInput(subcommandPath, options, arguments)
            handler.{{.HandlerMethodName}}(input)
        }
{{end}}
        else -> {}
    }
}

{{range .CommandList}}
// Input class for {{.HandlerMethodName}}
data class {{.HandlerInputType}}(
{{range .Options}}
    var {{.InputFieldName}}: {{.InputFieldType}} = {{.InputFieldInit}},
{{end}}
{{range .Arguments}}
    var {{.InputFieldName}}: {{.InputFieldType}} = {{if .Variadic}}listOf(){{else}}{{if eq .InputFieldType "String"}}""{{else if eq .InputFieldType "Long"}}0L{{else if eq .InputFieldType "Boolean"}}false{{end}}{{end}},
{{end}}

    var subcommand: List<String> = listOf(),
    var options: List<String> = listOf(),
    var arguments: List<String> = listOf(),

    var errorMessage: String = ""
) {
    // Resolves input from command line arguments
    internal fun resolveInput(subcommand: List<String>, options: List<String>, arguments: List<String>) {
        this.subcommand = subcommand
        this.options = options
        this.arguments = arguments

        for (arg in options) {
            val parts = arg.split("=", limit = 2)
            val optName = parts[0]
            val hasValue = parts.size > 1
            val lit = if (hasValue) parts[1] else ""

            when (optName) {
{{range .Options}}
                "{{.Option}}"{{if .ShortOption}}, "{{.ShortOption}}"{{end}} -> {
                    if (!hasValue) {
                        {{if or (eq .InputFieldType "Boolean") (eq .InputFieldType "List<Boolean>") -}}
                        {{if .Repeated -}}{{.InputFieldName}} += listOf(true){{else}}{{.InputFieldName}} = true{{end}}
                        {{- else -}}
                        errorMessage = "Value is not specified to option \"$optName\""
                        return
                        {{- end}}
                    } else {
                        {{if .Repeated -}}
                        try {
                            val v = {{if eq .InputFieldType "List<Boolean>" -}}parseBoolean(lit)
                            {{- else if eq .InputFieldType "List<Long>" -}}parseLong(lit)
                            {{- else -}}parseString(lit)
                            {{- end}}
                            {{.InputFieldName}} = {{.InputFieldName}} + listOf(v)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- else -}}
                        try {
                            {{.InputFieldName}} = parse{{.InputFieldType}}(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- end}}
                    }
                }
                {{if .Negation}}"-no{{.Option}}" -> {
                    if (!hasValue) {
                        {{if .Repeated -}}{{.InputFieldName}} += listOf(false){{else}}{{.InputFieldName}} = false{{end}}
                    } else {
                        {{if .Repeated -}}
                        try {
                            val v = {{if eq .InputFieldType "List<Boolean>" -}}parseBoolean(lit)
                            {{- else if eq .InputFieldType "List<Long>" -}}parseLong(lit)
                            {{- else -}}parseString(lit)
                            {{- end}}
                            {{.InputFieldName}} = {{.InputFieldName}} + listOf(!v)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- else -}}
                        try {
                            {{.InputFieldName}} = !parse{{.InputFieldType}}(lit)
                        } catch (e: Exception) {
                            errorMessage = "Value \"$lit\" is not assignable to option \"$optName\""
                            return
                        }
                        {{- end}}
                    }
                }
                {{end}}
{{end}}
                else -> {
                    errorMessage = "Unknown option \"$optName\""
                    return
                }
            }
        }

        {{if .Arguments}}val expectedArgs = {{len .Arguments}}{{end}}

    {{range $Index, $Argument := .Arguments}}
        {{if $Argument.Variadic -}}
        if (arguments.size < {{$Index}}) {
            errorMessage = "Too few arguments: required at least ${expectedArgs - 1}, got ${arguments.size}"
            return
        }
        try {
            {{if eq $Argument.InputFieldType "List<Boolean>" -}}
            {{$Argument.InputFieldName}} = parseArrayBoolean(arguments.subList({{$Index}}, arguments.size))
            {{- else if eq $Argument.InputFieldType "List<Long>" -}}
            {{$Argument.InputFieldName}} = parseArrayLong(arguments.subList({{$Index}}, arguments.size))
            {{- else -}}
            {{$Argument.InputFieldName}} = parseArrayString(arguments.subList({{$Index}}, arguments.size))
            {{- end}}
        } catch (e: Exception) {
            errorMessage = "Values [${arguments.subList({{$Index}}, arguments.size).joinToString(" ")}] are not assignable to arguments at [{{$Index}}:]"
            return
        }
        {{- else -}}
        if (arguments.size <= {{$Index}}) {
            errorMessage = "Too few arguments: required $expectedArgs, got ${arguments.size}"
            return
        }
        try {
            {{$Argument.InputFieldName}} = parse{{$Argument.InputFieldType}}(arguments[{{$Index}}])
        } catch (e: Exception) {
            errorMessage = "Value \"${arguments[{{$Index}}]}\" is not assignable to argument at [{{$Index}}]"
            return
        }
        {{- end}}
    {{end}}
    }
}
{{end}}

// Resolves the subcommand from arguments
internal fun resolveSubcommand(args: Array<String>): Triple<List<String>, List<String>, List<String>> {
    val subcommandSet = mapOf(
{{range .CommandList}}
        {{.PathLiteral}} to true,
{{end}}
    )

    val subcommandPath = mutableListOf<String>()

    for (arg in args) {
        if (arg == "--") {
            break
        }
        val pathLiteral = (subcommandPath + arg).joinToString(" ")
        if (!subcommandSet.containsKey(pathLiteral)) {
            break
        }
        subcommandPath.add(arg)
    }

    val restArgs = args.drop(subcommandPath.size)
    val options = mutableListOf<String>()
    val arguments = mutableListOf<String>()
    var idx = 0
    while (idx < restArgs.size) {
        val arg = restArgs[idx]
        if (arg == "--") {
            arguments.addAll(restArgs.subList(idx + 1, restArgs.size))
            break
        }
        if (arg.startsWith("-")) {
            options.add(arg)
        } else {
            arguments.add(arg)
        }
        idx++
    }

    return Triple(subcommandPath, options, arguments)
}

// Parses a string value to Boolean
internal fun parseBoolean(strValue: String): Boolean {
    return when(strValue) {
        "true", "1", "t" -> true
        "false", "0", "f" -> false
        else -> throw IllegalArgumentException("Invalid boolean value: $strValue")
    }
}

// Parses a string value to Long
internal fun parseLong(strValue: String): Long {
    return strValue.toLong()
}

// Parses a string value to String
internal fun parseString(strValue: String): String {
    return strValue
}

// Parses a list of string values to a list of Boolean
internal fun parseArrayBoolean(strValues: List<String>): List<Boolean> {
    return strValues.map { parseBoolean(it) }
}

// Parses a list of string values to a list of Long
internal fun parseArrayLong(strValues: List<String>): List<Long> {
    return strValues.map { parseLong(it) }
}

// Parses a list of string values to a list of String
internal fun parseArrayString(strValues: List<String>): List<String> {
    return strValues.map { parseString(it) }
}
fun getVersion(): String {
    return "{{.Program.Version}}"
}
fun getProgram(): String {
    return "{{.Program.Name}}"
}
// Gets documentation for a subcommand
fun getDoc(subcommands: List<String>): String {
    return when (subcommands.joinToString(" ")) {
{{range .CommandList}}
        {{.PathLiteral}} -> {{.DocText}}
{{end}}
        else -> throw IllegalArgumentException("Invalid subcommands: $subcommands")
    }
}
