<?php
// Code generated by {{.Generator}}, DO NOT EDIT.

namespace {{.Namespace}};

/**
 * Interface CLIHandler
 */
interface CLIHandler
{
    {{- range $Index, $Command := .CommandList }}
    /**
     * @param {{.HandlerInputType}} $input
     */
    public function {{.HandlerMethodName}}({{.HandlerInputType}} $input): void;
    {{- end }}
}

{{range $Index, $Command := .CommandList}}
/**
 * Class {{.HandlerInputType}}
 * {{- range $Index, $Option := .Options }}
 * @property {{$Option.InputFieldType}} ${{.InputFieldName}} {{ end }}
 * {{- range $Index, $Argument := .Arguments }}
 * @property {{$Argument.InputFieldType}} ${{.InputFieldName}} {{ end }}
 *
 * @property string[] $Subcommand
 * @property string[] $Options
 * @property string[] $Arguments
 * @property string $ErrorMessage
 */
class {{.HandlerInputType}} {
    {{- range $Index, $Option := .Options }}
    /** @var {{$Option.InputFieldDocType}} */
    public {{$Option.InputFieldType}} ${{.InputFieldName}};
    {{- end }}
    {{- range $Index, $Argument := .Arguments }}
    /** @var {{$Argument.InputFieldDocType}} */
    public {{$Argument.InputFieldType}} ${{.InputFieldName}};
    {{- end }}
    /** @var string[] */
    public array $Subcommand = [];
    /** @var string[] */
    public array $Options = [];
    /** @var string[] */
    public array $Arguments = [];
    /** @var string */
    public string $ErrorMessage = '';

    /**
     * @param string[] $subcommand
     * @param string[] $options
     * @param string[] $arguments
     */
    public function resolveInput(array $subcommand, array $options, array $arguments): void {
        {{- range $Index, $Option := .Options }}
        $this->{{.InputFieldName}} = {{if eq $Option.InputFieldType "bool"}}false{{else if eq $Option.InputFieldType "int"}}0{{else if eq $Option.InputFieldType "string"}}""{{else}}[]{{end}};
        {{- end }}
        $this->Subcommand = $subcommand;
        $this->Options = $options;
        $this->Arguments = $arguments;
        $this->ErrorMessage = '';
        foreach ($this->Options as $arg) {
            $cut = strpos($arg, '=');
            $optName = $cut !== false ? substr($arg, 0, $cut) : $arg;
            $lit = $cut !== false ? substr($arg, $cut + 1) : '';
            switch ($optName) {
                {{- range $Index, $Option := .Options}}
                case '{{.Option}}'{{if .ShortOption}}:
                case '{{.ShortOption}}'{{end}}:
                    if ($cut === false) {
                        {{if or (eq $Option.InputFieldDocType "bool") (eq $Option.InputFieldDocType "bool[]") -}}
                        $lit = 'true';
                        {{- else -}}
                        $this->ErrorMessage = "value is not specified to option '$optName'";
                        return;
                        {{- end}}
                    }
                    $v = Helper::parseValue('{{.InputFieldDocType}}', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    {{if $Option.Repeated -}}
                    $this->{{.InputFieldName}}[] = $v;
                    {{- else -}}
                    $this->{{.InputFieldName}} = $v;
                    {{- end}}
                    break;
                {{if .Negation}}case '-no{{.Option}}':
                    if ($cut === false) $lit = 'true';
                    $v = Helper::parseValue('{{.InputFieldDocType}}', $lit);
                    if ($v === null) {
                        $this->ErrorMessage = "value '$lit' is not assignable to option '$optName'";
                        return;
                    }
                    {{if $Option.Repeated -}}
                    $this->{{.InputFieldName}}[] = !$v;
                    {{- else -}}
                    $this->{{.InputFieldName}} = !$v;
                    {{- end}}
                    break;
                {{end}}
                {{end}}
                default:
                    $this->ErrorMessage = "unknown option '$optName'";
                    return;
            }
        }
        $expectedArgs = {{len .Arguments}};
        {{range $Index, $Argument := .Arguments}}
        {{if $Argument.Variadic -}}
        if (count($this->Arguments) < {{$Index}}) {
            $this->ErrorMessage = "too few arguments: required at least " . ($expectedArgs-1) . ", got " . count($this->Arguments);
            return;
        }
        $v = Helper::parseValue('{{.InputFieldDocType}}', ...array_slice($this->Arguments, {{$Index}}));
        if ($v === null) {
            $this->ErrorMessage = "values [" . implode(' ', array_slice($this->Arguments, {{$Index}})) . "] are not assignable to arguments at [{{$Index}}:]";
            return;
        }
        $this->{{.InputFieldName}} = $v;
        {{- else -}}
        if (count($this->Arguments) <= {{$Index}}) {
            $this->ErrorMessage = "too few arguments: required $expectedArgs, got " . count($this->Arguments);
            return;
        }
        $v = Helper::parseValue('{{.InputFieldDocType}}', ...array_slice($this->Arguments, {{$Index}}));
        if ($v === null) {
            $this->ErrorMessage = "value '" . $this->Arguments[{{$Index}}] . "' is not assignable to argument at [{{$Index}}]";
            return;
        }
        $this->{{.InputFieldName}} = $v;
        {{- end}}
        {{end}}
    }
}
{{end}}

class Helper {
    /**
     * @param string[] $args
     * @return array{0: string[], 1: string[], 2: string[]}
     */
    static function resolveArgs(array $args): array {
        if (count($args) === 0) {
            throw new \RuntimeException('command line arguments are too few');
        }
        $subcommandSet = [
            {{range .CommandList}}{{.PathLiteral}} => true,{{end}}
        ];
        $subcommandPath = [];
        $options = [];
        $arguments = [];
        for ($i = 1; $i < count($args); ++$i) {
            if ($args[$i] === '--') break;
            $pathLiteral = implode(' ', array_merge($subcommandPath, [$args[$i]]));
            if (!isset($subcommandSet[$pathLiteral])) break;
            $subcommandPath[] = $args[$i];
        }
        $restArgs = array_slice($args, 1 + count($subcommandPath));
        foreach ($restArgs as $idx => $arg) {
            if ($arg === '--') {
                $arguments = array_merge($arguments, array_slice($restArgs, $idx + 1));
                break;
            }
            if (strpos($arg, '-') === 0) {
                $options[] = $arg;
            } else {
                $arguments[] = $arg;
            }
        }
        return [$subcommandPath, $options, $arguments];
    }

    /**
     * @param string $typ
     * @param string ...$strValue
     * @return mixed|null
     */
    static function parseValue(string $typ, ...$strValue) {
        switch ($typ) {
            case 'bool[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = Helper::parseValue('bool', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'int[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = Helper::parseValue('int64', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'string[]':
                $val = [];
                foreach ($strValue as $str) {
                    $v = Helper::parseValue('string', $str);
                    if ($v === null) return null;
                    $val[] = $v;
                }
                return $val;
            case 'bool':
                $s = strtolower($strValue[0]);
                if (in_array($s, ['true', '1', 't'], true)) return true;
                if (in_array($s, ['false', '0', 'f'], true)) return false;
                return null;
            case 'int':
                if (is_numeric($strValue[0])) return (int)$strValue[0];
                return null;
            case 'string':
                return $strValue[0];
        }
        return null;
    }
}

class Cyamli {

    /**
     * Entry point
     * @param CLIHandler $handler
     * @param string[] $args
     */
    public static function Run(CLIHandler $handler, array $args): void {
        [$subcommandPath, $options, $arguments] = Helper::resolveArgs($args);
        switch (implode(' ', $subcommandPath)) {
        {{- range .CommandList }}
            case {{.PathLiteral}}:
                $input = new {{.HandlerInputType}}();
                $input->resolveInput($subcommandPath, $options, $arguments);
                $handler->{{.HandlerMethodName}}($input);
                break;
        {{- end }}
        }
    }

    public static function GetVersion(): string {
        return {{printf "%q" .Program.Version}};
    }
    public static function GetProgram(): string {
        return {{printf "%q" .Program.Name}};
    }
    public static function GetDoc(array $subcommands): string {
        switch (implode(' ', $subcommands)) {
        {{- range .CommandList}}
            case {{.PathLiteral}}:
                return {{.DocText}};
        {{end}}
            default:
                throw new \RuntimeException('invalid subcommands: ' . implode(', ', $subcommands));
        }
    }

}