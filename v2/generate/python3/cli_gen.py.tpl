# Code generated by {{.Generator}}, DO NOT EDIT.

import sys
import abc
from typing import List, Optional, Any, Dict, Callable, Union, TypeVar, Generic, cast, Tuple

class CLIHandler(abc.ABC):
    {{- range $Index, $Command := .CommandList}}
    @abc.abstractmethod
    def {{$Command.HandlerMethodName}}(self, input_obj: '{{$Command.HandlerInputType}}') -> None:
        pass
    {{end -}}

{{range $Index, $Command := .CommandList}}
class {{$Command.HandlerInputType}}:
    def __init__(self):
        {{- range $Index, $Option := $Command.Options}}
        self.{{$Option.InputFieldName}}: {{$Option.InputFieldType}} = None
        {{end -}}
        {{- range $Index, $Argument := $Command.Arguments}}
        self.{{$Argument.InputFieldName}}: {{$Argument.InputFieldType}} = None
        {{end -}}

        self.subcommand: List[str] = []
        self.options: List[str] = []
        self.arguments: List[str] = []

        self.error_message: Optional[str] = None

    def resolve_input(self, subcommand: List[str], options: List[str], arguments: List[str]) -> None:
        # Initialize default values
        {{- range $Index, $Option := $Command.Options}}
        self.{{$Option.InputFieldName}} = {{$Option.InputFieldInit}}
        {{end -}}
        self.subcommand = subcommand
        self.options = options
        self.arguments = arguments

        # Process options
        for arg in self.options:
            if "=" in arg:
                opt_name, lit = arg.split("=", 1)
                cut = True
            else:
                opt_name = arg
                lit = ""
                cut = False

            # Handle options
            {{- range $Index, $Option := $Command.Options}}
            if opt_name in ["{{$Option.Option}}"{{if $Option.ShortOption}}, "{{$Option.ShortOption}}"{{end}}]:
                if not cut:
                    {{if or (eq $Option.InputFieldType "bool") (eq $Option.InputFieldType "List[bool]") -}}
                    lit = "True"
                    {{- else -}}
                    self.error_message = "value is not specified to option " + repr(opt_name)
                    return
                    {{- end}}

                try:
                    v = parse_value(lit, "{{$Option.InputFieldType}}")
                    {{if $Option.Repeated -}}
                    self.{{$Option.InputFieldName}} += v
                    {{- else -}}
                    self.{{$Option.InputFieldName}} = v
                    {{- end}}
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            {{if $Option.Negation -}}
            elif opt_name == "-no{{$Option.Option}}":
                if not cut:
                    lit = "True"
                try:
                    v = parse_value(lit, "{{$Option.InputFieldType}}")
                    {{if $Option.Repeated -}}
                    self.{{$Option.InputFieldName}} += [not vi for vi in v]
                    {{- else -}}
                    self.{{$Option.InputFieldName}} = not v
                    {{- end}}
                except ValueError as e:
                    self.error_message = "value " + repr(lit) + " is not assignable to option " + repr(opt_name)
                    return
                continue
            {{- end}}
            {{end}}
            self.error_message = "unknown option " + repr(opt_name)
            return

        # Process positional arguments
        expected_args = {{len $Command.Arguments}}

        {{range $Index, $Argument := .Arguments -}}
        {{if $Argument.Variadic -}}
        if len(self.arguments) < {{$Index}}:
            self.error_message = "too few arguments: required at least " + str(expected_args-1) + ", got " + str(len(self.arguments))
            return

        try:
            self.{{$Argument.InputFieldName}} = sum([parse_value(arg, "{{$Argument.InputFieldType}}") for arg in self.arguments[{{$Index}}:]], [])
        except ValueError as e:
            self.error_message = "values " + ' '.join(self.arguments[{{$Index}}:]) + " are not assignable to arguments at [" + str({{$Index}}) + ":]"
            return
        {{- else -}}
        if len(self.arguments) <= {{$Index}}:
            self.error_message = "too few arguments: required " + str(expected_args) + ", got " + str(len(self.arguments))
            return

        try:
            self.{{$Argument.InputFieldName}} = parse_value(self.arguments[{{$Index}}], "{{$Argument.InputFieldType}}")
        except ValueError as e:
            self.error_message = "value " + repr(self.arguments[{{$Index}}]) + " is not assignable to argument at [" + str({{$Index}}) + "]"
            return
        {{- end}}
        {{end -}}
{{end}}

def resolve_args(args: List[str]) -> Tuple[List[str], List[str], List[str]]:
    if not args:
        raise ValueError("command line arguments are too few")

    subcommand_set = {
        {{range .CommandList}}{{.PathLiteral}}: True,{{end}}
    }

    subcommand_path = []

    for arg in args[1:]:
        if arg == "--":
            break

        path_literal = " ".join(subcommand_path + [arg])
        if path_literal not in subcommand_set:
            break

        subcommand_path.append(arg)

    rest_args = args[1+len(subcommand_path):]

    i = 0
    options = []
    arguments = []
    while i < len(rest_args):
        arg = rest_args[i]
        if arg == "--":
            arguments.extend(rest_args[i+1:])
            break
        elif arg.startswith("-"):
            options.append(arg)
        else:
            arguments.append(arg)
        i += 1

    return subcommand_path, options, arguments

def parse_value(value: str, type_name: str) -> Any:
    """Parse a string value into the specified type."""
    # Handle basic types
    if type_name == "bool":
        if value.lower() in ("true", "t", "yes", "y", "1"):
            return True
        elif value.lower() in ("false", "f", "no", "n", "0"):
            return False
        raise ValueError("cannot parse " + repr(value) + " as bool")

    elif type_name == "int":
        try:
            return int(value)
        except ValueError:
            raise ValueError("cannot parse " + repr(value) + " as int")

    elif type_name == "str":
        return value

    # Handle list types (e.g., List[str])
    elif type_name.startswith("List[") and type_name.endswith("]"):
        inner_type = type_name[5:-1]  # Extract the type inside List[...]
        return [parse_value(value, inner_type)]

    # If we get here, the type is not supported
    raise ValueError("unsupported type: " + type_name)

def run(handler: CLIHandler, args: List[str]) -> None:
    """Entry point for the CLI application."""
    subcommand_path, options, arguments = resolve_args(args)
    subcommand_str = " ".join(subcommand_path)

    {{- range .CommandList}}
    if subcommand_str == {{.PathLiteral}}:
        input_obj = {{.HandlerInputType}}()
        input_obj.resolve_input(subcommand_path, options, arguments)
        handler.{{.HandlerMethodName}}(input_obj)
    {{end -}}
    else:
        return

def get_version() -> str:
    return "{{.Program.Version}}"

def get_program() -> str:
    return "{{.Program.Name}}"

def get_doc(subcommands: List[str]) -> str:
    """Get documentation for a command."""
    subcommand_str = " ".join(subcommands)

    {{- range .CommandList}}
    if subcommand_str == {{.PathLiteral}}:
        return {{.DocText}}
    {{end -}}

    # If we get here, the subcommand is invalid
    raise ValueError(f"invalid subcommands: {subcommands}")
