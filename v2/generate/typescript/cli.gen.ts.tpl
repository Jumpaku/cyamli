// Code generated by {{.Generator}}, DO NOT EDIT.

/**
 * Interface for CLI handlers
 */
export interface CLIHandler {
{{range $Index, $Command := .CommandList}}
  {{$Command.HandlerMethodName}}(input: {{$Command.HandlerInputType}}): Promise<void>;
{{end}}
}

/**
 * Entry point for the CLI application
 */
export async function run(handler: CLIHandler, args: string[]): Promise<void> {
  const [subcommandPath, restArgs] = resolveSubcommand(args);

  switch (subcommandPath.join(' ')) {
{{range .CommandList}}
  case {{.PathLiteral}}:
    {
      const input = new {{.HandlerInputType}}();
      input.resolveInput(restArgs);
      return handler.{{.HandlerMethodName}}(input);
    }
{{end}}
  }
}

{{range $Index, $Command := .CommandList}}
/**
 * Input class for {{$Command.HandlerMethodName}}
 */
export class {{$Command.HandlerInputType}} {
{{range $Index, $Option := $Command.Options}}
  {{$Option.InputFieldName}}: {{$Option.InputFieldType}} = {{$Option.InputFieldInit}};
{{end}}
{{range $Index, $Argument := $Command.Arguments}}
  {{$Argument.InputFieldName}}: {{$Argument.InputFieldType}} = {{if eq $Argument.InputFieldType "string"}}""{{else if eq $Argument.InputFieldType "boolean"}}false{{else if eq $Argument.InputFieldType "number"}}0{{else if eq $Argument.InputFieldType "string[]"}}[]{{else if eq $Argument.InputFieldType "boolean[]"}}[]{{else if eq $Argument.InputFieldType "number[]"}}[]{{else}}undefined as any{{end}};
{{end}}

  subcommand: string[] = [];
  options: string[] = [];
  arguments: string[] = [];

  errorMessage: string | null = null;

  /**
   * String representation of the input
   */
  toString(): string {
    const lines: string[] = [];
    lines.push(`Subcommand: [${this.subcommand.join(' ')}]`);
    lines.push(`Options: [${this.options.join(', ')}]`);
    lines.push(`Arguments: [${this.arguments.join(', ')}]`);
{{range $Index, $Option := $Command.Options}}
    lines.push(`{{$Option.InputFieldName}}: ${this.{{$Option.InputFieldName}}}`);
{{end}}
{{range $Index, $Argument := $Command.Arguments}}
    lines.push(`{{$Argument.InputFieldName}}: ${this.{{$Argument.InputFieldName}}}`);
{{end}}
    if (this.errorMessage) {
      lines.push(`Error: ${this.errorMessage}`);
    }
    return lines.join('\n');
  }

  resolveInput(restArgs: string[]): void {
    this.subcommand = {{$Command.PathLiteral}}.split(' ');

    for (let idx = 0; idx < restArgs.length; idx++) {
      const arg = restArgs[idx];
      if (arg === '--') {
        this.arguments.push(...restArgs.slice(idx + 1));
        break;
      }
      if (arg.startsWith('-')) {
        this.options.push(arg);
      } else {
        this.arguments.push(arg);
      }
    }

    for (const arg of this.options) {
      const cut = arg.indexOf('=');
      let optName: string;
      let lit: string | undefined;

      if (cut >= 0) {
        optName = arg.substring(0, cut);
        lit = arg.substring(cut + 1);
      } else {
        optName = arg;
      }

      switch (optName) {
{{range $Index, $Option := $Command.Options}}
      case '{{$Option.Option}}':
{{if $Option.ShortOption}}      case '{{$Option.ShortOption}}':{{end}}
        if (cut < 0) {
  {{if eq $Option.InputFieldType "boolean"}}
          lit = 'true';
  {{else}}
          this.errorMessage = `Value is not specified to option "${optName}"`;
          return;
  {{end}}
        }
  {{if $Option.Repeated}}
        try {
          const v = parseValue(lit!, '{{$Option.InputFieldType}}');
          this.{{$Option.InputFieldName}} = [...this.{{$Option.InputFieldName}}, ...v];
        } catch (e) {
          this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
          return;
        }
  {{else}}
        try {
          this.{{$Option.InputFieldName}} = parseValue(lit!, '{{$Option.InputFieldType}}');
        } catch (e) {
          this.errorMessage = `Value "${lit}" is not assignable to option "${optName}"`;
          return;
        }
  {{end}}
        break;
{{end}}
      default:
        this.errorMessage = `Unknown option "${optName}"`;
        return;
      }
    }

    const expectedArgs = {{len $Command.Arguments}};

{{range $Index, $Argument := .Arguments}}
  {{if $Argument.Variadic}}
    if (this.arguments.length < {{$Index}}) {
      this.errorMessage = `Too few arguments: required at least ${expectedArgs - 1}, got ${this.arguments.length}`;
      return;
    }
    try {
      this.{{$Argument.InputFieldName}} = this.arguments.slice({{$Index}}).map(s => parseValue(s, '{{$Argument.InputFieldType}}')).flat();
    } catch (e) {
      this.errorMessage = `Values [${this.arguments.slice({{$Index}}).join(' ')}] are not assignable to arguments at [{{$Index}}:]`;
      return;
    }
  {{else}}
    if (this.arguments.length <= {{$Index}}) {
      this.errorMessage = `Too few arguments: required ${expectedArgs}, got ${this.arguments.length}`;
      return;
    }
    try {
      this.{{$Argument.InputFieldName}} = parseValue(this.arguments[{{$Index}}], '{{$Argument.InputFieldType}}');
    } catch (e) {
      this.errorMessage = `Value "${this.arguments[{{$Index}}]}" is not assignable to argument at [{{$Index}}]`;
      return;
    }
  {{end}}
{{end}}
  }
}
{{end}}

/**
 * Resolves the subcommand from the arguments
 */
function resolveSubcommand(args: string[]): [string[], string[]] {
  const subcommandSet: {[key: string]: boolean} = {
{{range .CommandList}}    {{.PathLiteral}}: true,
{{end}}
  };

  const subcommandPath: string[] = [];

  for (const arg of args) {
    if (arg === '--') {
      break;
    }
    const pathLiteral = [...subcommandPath, arg].join(' ');
    if (!subcommandSet[pathLiteral]) {
      break;
    }
    subcommandPath.push(arg);
  }

  return [subcommandPath, args.slice(subcommandPath.length)];
}

/**
 * Parses a string value to the specified type
 */
function parseValue(strValue: string, typeName: string): any {
  switch (typeName) {
    case 'boolean[]':
      return [parseValue(strValue, 'boolean')];
    case 'number[]':
      return [parseValue(strValue, 'number')];
    case 'string[]':
      return [parseValue(strValue, 'string')];
    case 'boolean':
      if (['true', 't', '1'].includes(strValue.toLowerCase())) return true;
      if (['false', 'f', '0'].includes(strValue.toLowerCase())) return false;
      throw new Error(`Failed to parse "${strValue}" as boolean`);
    case 'number':
      const num = parseInt(strValue, 10);
      if (isNaN(num)) throw new Error(`Failed to parse "${strValue}" as number`);
      return num;
    case 'string':
      return strValue;
    default:
      throw new Error(`Unsupported type: ${typeName}`);
  }
}

/**
 * Returns the version of the program.
 */
export function getVersion(): string {
  return '{{.Program.Version}}';
}

/**
 * Returns the program name.
 */
export function getProgram(): string {
  return '{{.Program.Name}}';
}

/**
 * Gets documentation for a subcommand
 */
export function getDoc(subcommands: string[]): string {
  switch (subcommands.join(' ')) {
{{range .CommandList}}
    case {{.PathLiteral}}:
      return {{.DocText}};
{{end}}
    default:
      throw new Error(`Invalid subcommands: ${subcommands}`);
  }
}
